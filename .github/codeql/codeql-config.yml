# CodeQL Configuration for TMI
# https://docs.github.com/en/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/customizing-your-advanced-setup-for-code-scanning

name: "TMI CodeQL Config"

# Use security-extended queries for comprehensive analysis
queries:
  - uses: security-extended
  - uses: security-and-quality

# Path filters - exclude generated code and development-only scripts
paths-ignore:
  # Auto-generated OpenAPI code (contains many false positives from oapi-codegen)
  - api/api.go
  # Development-only Python scripts (OAuth testing harness, deployment tools)
  # These intentionally log OAuth tokens/credentials for debugging purposes
  - scripts/oauth-client-callback-stub.py
  - scripts/setup-heroku-env.py
  - scripts/parse-cats-results.py

# Query filters to reduce false positives
query-filters:
  # Exclude clear-text logging alerts from Python dev scripts
  # These are development-only tools that intentionally log OAuth tokens for debugging
  - exclude:
      id: py/clear-text-logging-sensitive-data
  # Exclude go/log-injection - TMI's slogging package sanitizes all log messages
  # via SanitizeLogMessage() which removes control characters (CWE-117 mitigation).
  # CodeQL doesn't understand this sanitization, so we exclude the query.
  # See documentation below for details.
  - exclude:
      id: go/log-injection

# =============================================================================
# RESOLVED - Log Injection (go/log-injection) - EXCLUDED
# =============================================================================
# The TMI slogging package sanitizes all log messages by calling
# SanitizeLogMessage() which removes newlines, carriage returns, and tabs
# that could be used for log injection attacks (CWE-117).
#
# Implementation details (internal/slogging/):
#   - logger.go: Logger.Debug/Info/Warn/Error call SanitizeLogMessage()
#   - context.go: ContextLogger and FallbackLogger also sanitize
#   - redaction.go: SanitizeLogMessage() strips \n, \r, \t characters
#
# CodeQL's go/log-injection query doesn't recognize that data flowing through
# slogging methods is sanitized, resulting in false positives. Since all
# logging in TMI goes through slogging, we exclude this query entirely.
#
# The sanitization is tested in internal/slogging/logger_test.go.
# =============================================================================

# =============================================================================
# KNOWN FALSE POSITIVES - GORM Map-Based Queries (go/sql-injection)
# =============================================================================
# CodeQL flags GORM's map-based Where() queries as SQL injection vulnerabilities.
# These are FALSE POSITIVES because GORM parameterizes all values internally.
#
# Pattern flagged:
#   db.Where(map[string]interface{}{"column_name": userValue}).First(&entity)
#
# Why it's safe:
#   1. Map keys are hard-coded field names (not user input)
#   2. GORM converts keys to column names via its naming strategy
#   3. Values are parameterized - GORM generates "WHERE column = ?" with bound params
#   4. This pattern is used for Oracle cross-database compatibility
#
# Affected files (dismiss these alerts in GitHub as "False positive"):
#   - api/admin_checker.go:28                         (GetGroupUUIDsByNames)
#   - api/authorization_enrichment.go:65,71,94,98,181 (user lookup queries)
#   - api/database_store_gorm.go:44,51,57             (resolveUserIdentifierToUUID)
#   - api/project_store_gorm.go:60,208,545,616,651    (project CRUD + validation)
#   - api/team_middleware.go:45                        (IsTeamMemberOrAdmin)
#   - api/team_store_gorm.go:691                      (team relationship traversal)
#   - auth/repository/user_repository.go:65           (GetByProviderID)
#
# Reason: "GORM map-based queries are parameterized internally"
# =============================================================================
