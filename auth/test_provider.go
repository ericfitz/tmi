package auth

import (
	"context"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"math/big"
	"net/http"
	"net/url"
	"os"
	"regexp"
	"strings"
	"time"

	"github.com/ericfitz/tmi/internal/slogging"
	"golang.org/x/oauth2"
)

// TestProvider implements the TMI internal OAuth provider
// In dev/test builds (TMI_BUILD_MODE=dev|test): supports Authorization Code flow with ephemeral user creation
// In production builds: Only supports Client Credentials Grant for machine-to-machine authentication
type TestProvider struct {
	*BaseProvider
	clientSecret string
}

// NewTestProvider creates a new test OAuth provider
func NewTestProvider(config OAuthProviderConfig, callbackURL string) *TestProvider {
	// Use a fixed well-known secret for testing
	testSecret := "test-oauth-secret-12345" // #nosec G101 -- This is intentionally a well-known test secret

	baseConfig := &oauth2.Config{
		ClientID:     config.ClientID,
		ClientSecret: testSecret,
		RedirectURL:  callbackURL,
		Scopes:       config.Scopes,
		Endpoint: oauth2.Endpoint{
			AuthURL:  config.AuthorizationURL,
			TokenURL: config.TokenURL,
		},
	}

	httpClient := &http.Client{Timeout: 10 * time.Second}

	return &TestProvider{
		BaseProvider: &BaseProvider{
			config:       config,
			oauth2Config: baseConfig,
			httpClient:   httpClient,
		},
		clientSecret: testSecret,
	}
}

// GetAuthorizationURL returns the test authorization URL
// For the test provider, we'll create a direct callback URL instead of an external redirect
func (p *TestProvider) GetAuthorizationURL(state string) string {
	// For test provider, generate a fake auth code and redirect directly to callback
	authCode := fmt.Sprintf("test_auth_code_%d", time.Now().Unix())

	callbackURL := p.oauth2Config.RedirectURL
	if callbackURL == "" {
		// Fallback to default callback
		callbackURL = "http://localhost:8080/oauth2/callback"
	}

	// Parse the callback URL and add query parameters
	if parsedURL, err := url.Parse(callbackURL); err == nil {
		params := url.Values{}
		params.Add("code", authCode)
		params.Add("state", state)
		parsedURL.RawQuery = params.Encode()
		return parsedURL.String()
	}

	// Fallback if URL parsing fails
	return fmt.Sprintf("%s?code=%s&state=%s", callbackURL, authCode, state)
}

// ExchangeCode validates the authorization code and returns tokens only for valid codes
func (p *TestProvider) ExchangeCode(ctx context.Context, code string) (*TokenResponse, error) {
	// Check if this is a production build - authorization code flow (ephemeral user creation) is disabled in production
	// Client Credentials Grant is allowed in all builds (production + dev/test)
	if !isDevOrTestBuild() {
		logger := slogging.Get()
		logger.Warn("Authorization code flow not supported for TMI provider in production (use client credentials grant instead)")
		return nil, fmt.Errorf("authorization code flow not supported for TMI provider in production (use client credentials grant instead)")
	}

	// Validate authorization code format for test provider
	// Valid codes should start with "test_auth_code_" followed by a timestamp or "stepci"
	if code == "" {
		return nil, fmt.Errorf("authorization code is required")
	}

	// Check for valid test code patterns
	validPatterns := []string{
		"test_auth_code_",       // Generated by GetAuthorizationURL
		"test_auth_code_stepci", // Used by StepCI workaround
	}

	isValid := false
	for _, pattern := range validPatterns {
		if code == pattern || (len(code) > len(pattern) && code[:len(pattern)] == pattern) {
			isValid = true
			break
		}
	}

	if !isValid {
		return nil, fmt.Errorf("invalid authorization code: %s", code)
	}

	// Generate a fake access token for valid codes only
	// Include login_hint in the access token if provided
	timestamp := time.Now().Unix()
	accessToken := fmt.Sprintf("test_access_token_%d", timestamp)

	// Extract login_hint from authorization code if present
	userHint := p.extractUserHintFromAuthCode(code)

	// Also check context as fallback for backward compatibility
	if userHint == "" {
		if contextHint, ok := ctx.Value(userHintContextKey).(string); ok && contextHint != "" {
			userHint = contextHint
		}
	}

	logger := slogging.Get()
	if userHint != "" {
		logger.Debug("[TEST_PROVIDER] ExchangeCode: Found login_hint: %s", userHint)
		// Validate and sanitize login_hint
		if validatedHint := p.validateUserHint(userHint); validatedHint != "" {
			// Encode login_hint into access token
			encodedHint := base64.URLEncoding.EncodeToString([]byte(validatedHint))
			accessToken = fmt.Sprintf("test_access_token_%d_hint_%s", timestamp, encodedHint)
			logger.Debug("[TEST_PROVIDER] ExchangeCode: Generated token with hint: %s", accessToken)
		} else {
			logger.Debug("[TEST_PROVIDER] ExchangeCode: login_hint validation failed: %s", userHint)
		}
	} else {
		logger.Debug("[TEST_PROVIDER] ExchangeCode: No login_hint found in code or context")
	}

	idToken := p.generateTestIDToken()

	return &TokenResponse{
		AccessToken: accessToken,
		TokenType:   "Bearer",
		ExpiresIn:   3600,
		IDToken:     idToken,
	}, nil
}

// GetUserInfo returns fake user information
func (p *TestProvider) GetUserInfo(ctx context.Context, accessToken string) (*UserInfo, error) {
	logger := slogging.Get()
	logger.Debug("[TEST_PROVIDER] GetUserInfo: Called with access token: %s", accessToken)

	// Check if access token contains a login_hint
	userHint := p.extractUserHintFromToken(accessToken)
	logger.Debug("[TEST_PROVIDER] GetUserInfo: Extracted login_hint: %s", userHint)
	logger.Debug("[TEST_PROVIDER] GetUserInfo: Access token contains _hint_: %t", strings.Contains(accessToken, "_hint_"))

	if strings.Contains(accessToken, "_hint_") {
		parts := strings.Split(accessToken, "_hint_")
		logger.Debug("[TEST_PROVIDER] GetUserInfo: Split parts: %v", parts)
	}

	if userHint != "" {
		// Use the provided login_hint
		username := userHint
		email := fmt.Sprintf("%s@test.tmi", username)
		displayName := p.generateDisplayName(username)

		return &UserInfo{
			ID:            username,
			Email:         email,
			EmailVerified: false, // Test provider emails are not verified
			Name:          displayName,
			Locale:        "en-US", // Default to US English for test provider
		}, nil
	}

	// Fall back to random user generation
	randomNum, err := rand.Int(rand.Reader, big.NewInt(100000000))
	if err != nil {
		return nil, fmt.Errorf("failed to generate random number: %w", err)
	}

	username := fmt.Sprintf("testuser-%08d", randomNum)
	email := fmt.Sprintf("%s@test.tmi", username)

	return &UserInfo{
		ID:            username,
		Email:         email,
		EmailVerified: false, // Test provider emails are not verified
		Name:          fmt.Sprintf("Test User %08d", randomNum),
		Locale:        "en-US", // Default to US English for test provider
	}, nil
}

// ValidateIDToken validates the test ID token (always succeeds)
func (p *TestProvider) ValidateIDToken(ctx context.Context, idToken string) (*IDTokenClaims, error) {
	// Check if login_hint is available in context (for consistency with other methods)
	if userHint, ok := ctx.Value(userHintContextKey).(string); ok && userHint != "" {
		if validatedHint := p.validateUserHint(userHint); validatedHint != "" {
			username := validatedHint
			email := fmt.Sprintf("%s@test.tmi", username)
			displayName := p.generateDisplayName(username)

			return &IDTokenClaims{
				Subject:   username,
				Email:     email,
				Name:      displayName,
				ExpiresAt: time.Now().Add(time.Hour).Unix(),
				IssuedAt:  time.Now().Unix(),
				Issuer:    "test-oauth-provider",
				Audience:  p.config.ClientID,
			}, nil
		}
	}

	// Fall back to random user generation
	randomNum, err := rand.Int(rand.Reader, big.NewInt(100000000))
	if err != nil {
		return nil, fmt.Errorf("failed to generate random number: %w", err)
	}

	username := fmt.Sprintf("testuser-%08d", randomNum)
	email := fmt.Sprintf("%s@test.tmi", username)

	return &IDTokenClaims{
		Subject:   username,
		Email:     email,
		Name:      fmt.Sprintf("Test User %08d", randomNum),
		ExpiresAt: time.Now().Add(time.Hour).Unix(),
		IssuedAt:  time.Now().Unix(),
		Issuer:    "test-oauth-provider",
		Audience:  p.config.ClientID,
	}, nil
}

// generateTestIDToken creates a simple JWT-like token for testing
func (p *TestProvider) generateTestIDToken() string {
	header := map[string]interface{}{
		"alg": "HS256",
		"typ": "JWT",
	}

	payload := map[string]interface{}{
		"iss": "test-oauth-provider",
		"aud": p.config.ClientID,
		"exp": time.Now().Add(time.Hour).Unix(),
		"iat": time.Now().Unix(),
		"sub": "test-user",
	}

	headerBytes, _ := json.Marshal(header)
	payloadBytes, _ := json.Marshal(payload)

	// Simple base64-like encoding for test purposes
	return fmt.Sprintf("%x.%x.test-signature", headerBytes, payloadBytes)
}

// validateUserHint validates and sanitizes a login_hint
func (p *TestProvider) validateUserHint(hint string) string {
	if hint == "" {
		return ""
	}

	// Convert to lowercase and trim spaces
	hint = strings.ToLower(strings.TrimSpace(hint))

	// Validate length (3-20 characters)
	if len(hint) < 3 || len(hint) > 20 {
		return ""
	}

	// Validate format: alphanumeric characters and hyphens only
	validFormat := regexp.MustCompile(`^[a-z0-9-]+$`)
	if !validFormat.MatchString(hint) {
		return ""
	}

	// Don't allow hints that start or end with hyphens
	if strings.HasPrefix(hint, "-") || strings.HasSuffix(hint, "-") {
		return ""
	}

	return hint
}

// extractUserHintFromToken extracts login_hint from access token if present
func (p *TestProvider) extractUserHintFromToken(accessToken string) string {
	// Check if token contains hint pattern: test_access_token_{timestamp}_hint_{encoded_hint}
	if !strings.Contains(accessToken, "_hint_") {
		return ""
	}

	// Extract the encoded hint part
	parts := strings.Split(accessToken, "_hint_")
	if len(parts) != 2 {
		return ""
	}

	encodedHint := parts[1]
	decodedBytes, err := base64.URLEncoding.DecodeString(encodedHint)
	if err != nil {
		return ""
	}

	return string(decodedBytes)
}

// extractUserHintFromAuthCode extracts login_hint from authorization code if present
func (p *TestProvider) extractUserHintFromAuthCode(authCode string) string {
	// Check if auth code contains hint pattern: test_auth_code_{timestamp}_hint_{encoded_hint}
	if !strings.Contains(authCode, "_hint_") {
		return ""
	}

	// Extract the encoded hint part
	parts := strings.Split(authCode, "_hint_")
	if len(parts) != 2 {
		return ""
	}

	encodedHint := parts[1]
	decodedBytes, err := base64.URLEncoding.DecodeString(encodedHint)
	if err != nil {
		return ""
	}

	return string(decodedBytes)
}

// generateDisplayName creates a human-readable display name from username
func (p *TestProvider) generateDisplayName(username string) string {
	// Convert username to title case for display
	words := strings.Split(username, "-")
	for i, word := range words {
		if len(word) > 0 {
			words[i] = strings.ToUpper(string(word[0])) + word[1:]
		}
	}
	displayName := strings.Join(words, " ")

	// Add "(Test User)" suffix to indicate it's from test provider
	return fmt.Sprintf("%s (Test User)", displayName)
}

// isDevOrTestBuild checks if the current build mode allows ephemeral user creation
// Returns true if TMI_BUILD_MODE environment variable is set to "dev" or "test"
// Returns false for production builds (where TMI_BUILD_MODE is unset or set to other values)
func isDevOrTestBuild() bool {
	buildMode := os.Getenv("TMI_BUILD_MODE")
	return buildMode == "dev" || buildMode == "test"
}
