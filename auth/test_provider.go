//go:build dev || test

package auth

import (
	"context"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"math/big"
	"net/http"
	"net/url"
	"regexp"
	"strings"
	"time"

	"github.com/ericfitz/tmi/internal/logging"
	"golang.org/x/oauth2"
)

// TestProvider implements a test-only OAuth provider that always succeeds
type TestProvider struct {
	*BaseProvider
	clientSecret string
}

// NewTestProvider creates a new test OAuth provider
func NewTestProvider(config OAuthProviderConfig, callbackURL string) *TestProvider {
	// Use a fixed well-known secret for testing
	testSecret := "test-oauth-secret-12345"
	
	baseConfig := &oauth2.Config{
		ClientID:     config.ClientID,
		ClientSecret: testSecret,
		RedirectURL:  callbackURL,
		Scopes:       config.Scopes,
		Endpoint: oauth2.Endpoint{
			AuthURL:  config.AuthorizationURL,
			TokenURL: config.TokenURL,
		},
	}

	httpClient := &http.Client{Timeout: 10 * time.Second}
	
	return &TestProvider{
		BaseProvider: &BaseProvider{
			config:       config,
			oauth2Config: baseConfig,
			httpClient:   httpClient,
		},
		clientSecret: testSecret,
	}
}

// GetAuthorizationURL returns the test authorization URL
// For the test provider, we'll create a direct callback URL instead of an external redirect
func (p *TestProvider) GetAuthorizationURL(state string) string {
	// For test provider, generate a fake auth code and redirect directly to callback
	authCode := fmt.Sprintf("test_auth_code_%d", time.Now().Unix())
	
	callbackURL := p.oauth2Config.RedirectURL
	if callbackURL == "" {
		// Fallback to default callback
		callbackURL = "http://localhost:8080/oauth2/callback"
	}
	
	// Parse the callback URL and add query parameters
	if parsedURL, err := url.Parse(callbackURL); err == nil {
		params := url.Values{}
		params.Add("code", authCode)
		params.Add("state", state)
		parsedURL.RawQuery = params.Encode()
		return parsedURL.String()
	}
	
	// Fallback if URL parsing fails
	return fmt.Sprintf("%s?code=%s&state=%s", callbackURL, authCode, state)
}


// ExchangeCode validates the authorization code and returns tokens only for valid codes
func (p *TestProvider) ExchangeCode(ctx context.Context, code string) (*TokenResponse, error) {
	// Validate authorization code format for test provider
	// Valid codes should start with "test_auth_code_" followed by a timestamp or "stepci"
	if code == "" {
		return nil, fmt.Errorf("authorization code is required")
	}
	
	// Check for valid test code patterns
	validPatterns := []string{
		"test_auth_code_",     // Generated by GetAuthorizationURL
		"test_auth_code_stepci", // Used by StepCI workaround
	}
	
	isValid := false
	for _, pattern := range validPatterns {
		if code == pattern || (len(code) > len(pattern) && code[:len(pattern)] == pattern) {
			isValid = true
			break
		}
	}
	
	if !isValid {
		return nil, fmt.Errorf("invalid authorization code: %s", code)
	}
	
	// Generate a fake access token for valid codes only
	// Include login_hint in the access token if provided
	timestamp := time.Now().Unix()
	accessToken := fmt.Sprintf("test_access_token_%d", timestamp)
	
	// Extract login_hint from authorization code if present
	userHint := p.extractUserHintFromAuthCode(code)
	
	// Also check context as fallback for backward compatibility
	if userHint == "" {
		if contextHint, ok := ctx.Value(userHintContextKey).(string); ok && contextHint != "" {
			userHint = contextHint
		}
	}
	
	logger := logging.Get()
	if userHint != "" {
		logger.Debug("[TEST_PROVIDER] ExchangeCode: Found login_hint: %s", userHint)
		// Validate and sanitize login_hint
		if validatedHint := p.validateUserHint(userHint); validatedHint != "" {
			// Encode login_hint into access token
			encodedHint := base64.URLEncoding.EncodeToString([]byte(validatedHint))
			accessToken = fmt.Sprintf("test_access_token_%d_hint_%s", timestamp, encodedHint)
			logger.Debug("[TEST_PROVIDER] ExchangeCode: Generated token with hint: %s", accessToken)
		} else {
			logger.Debug("[TEST_PROVIDER] ExchangeCode: login_hint validation failed: %s", userHint)
		}
	} else {
		logger.Debug("[TEST_PROVIDER] ExchangeCode: No login_hint found in code or context")
	}
	
	idToken := p.generateTestIDToken()

	return &TokenResponse{
		AccessToken: accessToken,
		TokenType:   "Bearer",
		ExpiresIn:   3600,
		IDToken:     idToken,
	}, nil
}

// GetUserInfo returns fake user information
func (p *TestProvider) GetUserInfo(ctx context.Context, accessToken string) (*UserInfo, error) {
	logger := logging.Get()
	logger.Debug("[TEST_PROVIDER] GetUserInfo: Called with access token: %s", accessToken)
	
	// Check if access token contains a login_hint
	userHint := p.extractUserHintFromToken(accessToken)
	logger.Debug("[TEST_PROVIDER] GetUserInfo: Extracted login_hint: %s", userHint)
	logger.Debug("[TEST_PROVIDER] GetUserInfo: Access token contains _hint_: %t", strings.Contains(accessToken, "_hint_"))
	
	if strings.Contains(accessToken, "_hint_") {
		parts := strings.Split(accessToken, "_hint_")
		logger.Debug("[TEST_PROVIDER] GetUserInfo: Split parts: %v", parts)
	}
	
	if userHint != "" {
		// Use the provided login_hint
		username := userHint
		email := fmt.Sprintf("%s@test.tmi", username)
		displayName := p.generateDisplayName(username)
		
		return &UserInfo{
			ID:            username,
			Email:         email,
			EmailVerified: false, // Test provider emails are not verified
			Name:          displayName,
			Locale:        "en-US", // Default to US English for test provider
		}, nil
	}
	
	// Fall back to random user generation
	randomNum, err := rand.Int(rand.Reader, big.NewInt(100000000))
	if err != nil {
		return nil, fmt.Errorf("failed to generate random number: %w", err)
	}
	
	username := fmt.Sprintf("testuser-%08d", randomNum)
	email := fmt.Sprintf("%s@test.tmi", username)

	return &UserInfo{
		ID:            username,
		Email:         email,
		EmailVerified: false, // Test provider emails are not verified
		Name:          fmt.Sprintf("Test User %08d", randomNum),
		Locale:        "en-US", // Default to US English for test provider
	}, nil
}

// ValidateIDToken validates the test ID token (always succeeds)
func (p *TestProvider) ValidateIDToken(ctx context.Context, idToken string) (*IDTokenClaims, error) {
	// Check if login_hint is available in context (for consistency with other methods)
	if userHint, ok := ctx.Value(userHintContextKey).(string); ok && userHint != "" {
		if validatedHint := p.validateUserHint(userHint); validatedHint != "" {
			username := validatedHint
			email := fmt.Sprintf("%s@test.tmi", username)
			displayName := p.generateDisplayName(username)
			
			return &IDTokenClaims{
				Subject:   username,
				Email:     email,
				Name:      displayName,
				ExpiresAt: time.Now().Add(time.Hour).Unix(),
				IssuedAt:  time.Now().Unix(),
				Issuer:    "test-oauth-provider",
				Audience:  p.config.ClientID,
			}, nil
		}
	}
	
	// Fall back to random user generation
	randomNum, err := rand.Int(rand.Reader, big.NewInt(100000000))
	if err != nil {
		return nil, fmt.Errorf("failed to generate random number: %w", err)
	}

	username := fmt.Sprintf("testuser-%08d", randomNum)
	email := fmt.Sprintf("%s@test.tmi", username)

	return &IDTokenClaims{
		Subject:   username,
		Email:     email,
		Name:      fmt.Sprintf("Test User %08d", randomNum),
		ExpiresAt: time.Now().Add(time.Hour).Unix(),
		IssuedAt:  time.Now().Unix(),
		Issuer:    "test-oauth-provider",
		Audience:  p.config.ClientID,
	}, nil
}

// generateTestIDToken creates a simple JWT-like token for testing
func (p *TestProvider) generateTestIDToken() string {
	header := map[string]interface{}{
		"alg": "HS256",
		"typ": "JWT",
	}

	payload := map[string]interface{}{
		"iss": "test-oauth-provider",
		"aud": p.config.ClientID,
		"exp": time.Now().Add(time.Hour).Unix(),
		"iat": time.Now().Unix(),
		"sub": "test-user",
	}

	headerBytes, _ := json.Marshal(header)
	payloadBytes, _ := json.Marshal(payload)

	// Simple base64-like encoding for test purposes
	return fmt.Sprintf("%x.%x.test-signature", headerBytes, payloadBytes)
}

// validateUserHint validates and sanitizes a login_hint
func (p *TestProvider) validateUserHint(hint string) string {
	if hint == "" {
		return ""
	}
	
	// Convert to lowercase and trim spaces
	hint = strings.ToLower(strings.TrimSpace(hint))
	
	// Validate length (3-20 characters)
	if len(hint) < 3 || len(hint) > 20 {
		return ""
	}
	
	// Validate format: alphanumeric characters and hyphens only
	validFormat := regexp.MustCompile(`^[a-z0-9-]+$`)
	if !validFormat.MatchString(hint) {
		return ""
	}
	
	// Don't allow hints that start or end with hyphens
	if strings.HasPrefix(hint, "-") || strings.HasSuffix(hint, "-") {
		return ""
	}
	
	return hint
}

// extractUserHintFromToken extracts login_hint from access token if present
func (p *TestProvider) extractUserHintFromToken(accessToken string) string {
	// Check if token contains hint pattern: test_access_token_{timestamp}_hint_{encoded_hint}
	if !strings.Contains(accessToken, "_hint_") {
		return ""
	}
	
	// Extract the encoded hint part
	parts := strings.Split(accessToken, "_hint_")
	if len(parts) != 2 {
		return ""
	}
	
	encodedHint := parts[1]
	decodedBytes, err := base64.URLEncoding.DecodeString(encodedHint)
	if err != nil {
		return ""
	}
	
	return string(decodedBytes)
}

// extractUserHintFromAuthCode extracts login_hint from authorization code if present
func (p *TestProvider) extractUserHintFromAuthCode(authCode string) string {
	// Check if auth code contains hint pattern: test_auth_code_{timestamp}_hint_{encoded_hint}
	if !strings.Contains(authCode, "_hint_") {
		return ""
	}
	
	// Extract the encoded hint part
	parts := strings.Split(authCode, "_hint_")
	if len(parts) != 2 {
		return ""
	}
	
	encodedHint := parts[1]
	decodedBytes, err := base64.URLEncoding.DecodeString(encodedHint)
	if err != nil {
		return ""
	}
	
	return string(decodedBytes)
}

// generateDisplayName creates a human-readable display name from username
func (p *TestProvider) generateDisplayName(username string) string {
	// Convert username to title case for display
	words := strings.Split(username, "-")
	for i, word := range words {
		if len(word) > 0 {
			words[i] = strings.ToUpper(string(word[0])) + word[1:]
		}
	}
	displayName := strings.Join(words, " ")
	
	// Add "(Test User)" suffix to indicate it's from test provider
	return fmt.Sprintf("%s (Test User)", displayName)
}

