/*
 * TMI (Threat Modeling Improved) API
 * A RESTful API for collaborative threat modeling with full X6 graph library compatibility. This API provides schemas that align with AntV X6 cell object models for seamless integration with modern diagramming libraries. Supports OAuth 2.0 authentication with client callback integration for seamless single-page application authentication flows.  ## API Design v1.0.0  ### Authorization Model TMI uses hierarchical authorization: access control is defined at the ThreatModel level via the authorization field (readers, writers, owners). All child resources (Assets, Diagrams, Documents, Notes, Repositories, Threats) inherit permissions from their parent ThreatModel. This simplifies permission management and ensures consistent access control.  ### Bulk Operations Notes and Diagrams do not support bulk operations due to their unique creation workflows and lack of valid bulk use cases. All other resources (Threats, Assets, Documents, Repositories) support full bulk operations: POST (create), PUT (upsert), PATCH (partial update), DELETE (batch delete).  All resources support bulk metadata operations regardless of resource-level bulk support.  ### List Response Strategy - ThreatModels return summary information (TMListItem) because they contain many child objects that can be large. - Diagrams return summary information (DiagramListItem) because diagram data (cells, images) can be large. - Notes return summary information (NoteListItem) because the content field can be large. - Threats, Assets, Documents, Repositories return full schemas as they are relatively small and static.  ### PATCH Support All resources support PATCH for partial updates using JSON Patch (RFC 6902). This is particularly useful for: - Assets: Array field updates (affected_assets, trust_boundaries) ensuring no duplicates - Notes: Updating name/description without changing content field - All resources: Efficient updates without full object replacement 
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.Metadata;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
/**
 * Base schema for Threat with client-writable fields
 */
@Schema(description = "Base schema for Threat with client-writable fields")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2025-11-01T19:29:35.350343762Z[GMT]")

public class ThreatBase {
  @SerializedName("name")
  private String name = null;

  @SerializedName("description")
  private String description = null;

  @SerializedName("mitigation")
  private String mitigation = null;

  @SerializedName("diagram_id")
  private UUID diagramId = null;

  @SerializedName("cell_id")
  private UUID cellId = null;

  /**
   * Severity level of the threat
   */
  @JsonAdapter(SeverityEnum.Adapter.class)
  public enum SeverityEnum {
    @SerializedName("Unknown")
    UNKNOWN("Unknown"),
    @SerializedName("None")
    NONE("None"),
    @SerializedName("Low")
    LOW("Low"),
    @SerializedName("Medium")
    MEDIUM("Medium"),
    @SerializedName("High")
    HIGH("High"),
    @SerializedName("Critical")
    CRITICAL("Critical");

    private String value;

    SeverityEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static SeverityEnum fromValue(String input) {
      for (SeverityEnum b : SeverityEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<SeverityEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SeverityEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public SeverityEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return SeverityEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("severity")
  private SeverityEnum severity = null;

  @SerializedName("score")
  private BigDecimal score = null;

  @SerializedName("priority")
  private String priority = null;

  @SerializedName("mitigated")
  private Boolean mitigated = null;

  @SerializedName("status")
  private String status = null;

  @SerializedName("threat_type")
  private String threatType = null;

  @SerializedName("metadata")
  private List<Metadata> metadata = null;

  @SerializedName("issue_uri")
  private String issueUri = null;

  @SerializedName("asset_id")
  private UUID assetId = null;

  public ThreatBase name(String name) {
    this.name = name;
    return this;
  }

   /**
   * Name of the threat
   * @return name
  **/
  @Schema(required = true, description = "Name of the threat")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public ThreatBase description(String description) {
    this.description = description;
    return this;
  }

   /**
   * Description of the threat and risk to the organization
   * @return description
  **/
  @Schema(description = "Description of the threat and risk to the organization")
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }

  public ThreatBase mitigation(String mitigation) {
    this.mitigation = mitigation;
    return this;
  }

   /**
   * Recommended or planned mitigation(s) for the threat
   * @return mitigation
  **/
  @Schema(description = "Recommended or planned mitigation(s) for the threat")
  public String getMitigation() {
    return mitigation;
  }

  public void setMitigation(String mitigation) {
    this.mitigation = mitigation;
  }

  public ThreatBase diagramId(UUID diagramId) {
    this.diagramId = diagramId;
    return this;
  }

   /**
   * Unique identifier of the associated diagram (if applicable) (UUID)
   * @return diagramId
  **/
  @Schema(description = "Unique identifier of the associated diagram (if applicable) (UUID)")
  public UUID getDiagramId() {
    return diagramId;
  }

  public void setDiagramId(UUID diagramId) {
    this.diagramId = diagramId;
  }

  public ThreatBase cellId(UUID cellId) {
    this.cellId = cellId;
    return this;
  }

   /**
   * Unique identifier of the associated cell (if applicable) (UUID)
   * @return cellId
  **/
  @Schema(description = "Unique identifier of the associated cell (if applicable) (UUID)")
  public UUID getCellId() {
    return cellId;
  }

  public void setCellId(UUID cellId) {
    this.cellId = cellId;
  }

  public ThreatBase severity(SeverityEnum severity) {
    this.severity = severity;
    return this;
  }

   /**
   * Severity level of the threat
   * @return severity
  **/
  @Schema(required = true, description = "Severity level of the threat")
  public SeverityEnum getSeverity() {
    return severity;
  }

  public void setSeverity(SeverityEnum severity) {
    this.severity = severity;
  }

  public ThreatBase score(BigDecimal score) {
    this.score = score;
    return this;
  }

   /**
   * Numeric score representing the risk or impact of the threat
   * minimum: 0
   * maximum: 10
   * @return score
  **/
  @Schema(description = "Numeric score representing the risk or impact of the threat")
  public BigDecimal getScore() {
    return score;
  }

  public void setScore(BigDecimal score) {
    this.score = score;
  }

  public ThreatBase priority(String priority) {
    this.priority = priority;
    return this;
  }

   /**
   * Priority level for addressing the threat
   * @return priority
  **/
  @Schema(required = true, description = "Priority level for addressing the threat")
  public String getPriority() {
    return priority;
  }

  public void setPriority(String priority) {
    this.priority = priority;
  }

  public ThreatBase mitigated(Boolean mitigated) {
    this.mitigated = mitigated;
    return this;
  }

   /**
   * Whether the threat has been mitigated
   * @return mitigated
  **/
  @Schema(required = true, description = "Whether the threat has been mitigated")
  public Boolean isMitigated() {
    return mitigated;
  }

  public void setMitigated(Boolean mitigated) {
    this.mitigated = mitigated;
  }

  public ThreatBase status(String status) {
    this.status = status;
    return this;
  }

   /**
   * Current status of the threat
   * @return status
  **/
  @Schema(required = true, description = "Current status of the threat")
  public String getStatus() {
    return status;
  }

  public void setStatus(String status) {
    this.status = status;
  }

  public ThreatBase threatType(String threatType) {
    this.threatType = threatType;
    return this;
  }

   /**
   * Type or category of the threat
   * @return threatType
  **/
  @Schema(required = true, description = "Type or category of the threat")
  public String getThreatType() {
    return threatType;
  }

  public void setThreatType(String threatType) {
    this.threatType = threatType;
  }

  public ThreatBase metadata(List<Metadata> metadata) {
    this.metadata = metadata;
    return this;
  }

  public ThreatBase addMetadataItem(Metadata metadataItem) {
    if (this.metadata == null) {
      this.metadata = new ArrayList<Metadata>();
    }
    this.metadata.add(metadataItem);
    return this;
  }

   /**
   * Key-value pairs for additional threat metadata
   * @return metadata
  **/
  @Schema(description = "Key-value pairs for additional threat metadata")
  public List<Metadata> getMetadata() {
    return metadata;
  }

  public void setMetadata(List<Metadata> metadata) {
    this.metadata = metadata;
  }

  public ThreatBase issueUri(String issueUri) {
    this.issueUri = issueUri;
    return this;
  }

   /**
   * URL to an issue in an issue tracking system for this threat
   * @return issueUri
  **/
  @Schema(description = "URL to an issue in an issue tracking system for this threat")
  public String getIssueUri() {
    return issueUri;
  }

  public void setIssueUri(String issueUri) {
    this.issueUri = issueUri;
  }

  public ThreatBase assetId(UUID assetId) {
    this.assetId = assetId;
    return this;
  }

   /**
   * Unique identifier of the associated asset (if applicable) (UUID)
   * @return assetId
  **/
  @Schema(description = "Unique identifier of the associated asset (if applicable) (UUID)")
  public UUID getAssetId() {
    return assetId;
  }

  public void setAssetId(UUID assetId) {
    this.assetId = assetId;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ThreatBase threatBase = (ThreatBase) o;
    return Objects.equals(this.name, threatBase.name) &&
        Objects.equals(this.description, threatBase.description) &&
        Objects.equals(this.mitigation, threatBase.mitigation) &&
        Objects.equals(this.diagramId, threatBase.diagramId) &&
        Objects.equals(this.cellId, threatBase.cellId) &&
        Objects.equals(this.severity, threatBase.severity) &&
        Objects.equals(this.score, threatBase.score) &&
        Objects.equals(this.priority, threatBase.priority) &&
        Objects.equals(this.mitigated, threatBase.mitigated) &&
        Objects.equals(this.status, threatBase.status) &&
        Objects.equals(this.threatType, threatBase.threatType) &&
        Objects.equals(this.metadata, threatBase.metadata) &&
        Objects.equals(this.issueUri, threatBase.issueUri) &&
        Objects.equals(this.assetId, threatBase.assetId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(name, description, mitigation, diagramId, cellId, severity, score, priority, mitigated, status, threatType, metadata, issueUri, assetId);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ThreatBase {\n");
    
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    mitigation: ").append(toIndentedString(mitigation)).append("\n");
    sb.append("    diagramId: ").append(toIndentedString(diagramId)).append("\n");
    sb.append("    cellId: ").append(toIndentedString(cellId)).append("\n");
    sb.append("    severity: ").append(toIndentedString(severity)).append("\n");
    sb.append("    score: ").append(toIndentedString(score)).append("\n");
    sb.append("    priority: ").append(toIndentedString(priority)).append("\n");
    sb.append("    mitigated: ").append(toIndentedString(mitigated)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    threatType: ").append(toIndentedString(threatType)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    issueUri: ").append(toIndentedString(issueUri)).append("\n");
    sb.append("    assetId: ").append(toIndentedString(assetId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
