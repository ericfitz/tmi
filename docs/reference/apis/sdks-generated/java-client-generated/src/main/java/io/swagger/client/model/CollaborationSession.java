/*
 * TMI (Threat Modeling Improved) API
 * A RESTful API for collaborative threat modeling with full X6 graph library compatibility. This API provides schemas that align with AntV X6 cell object models for seamless integration with modern diagramming libraries. Supports OAuth 2.0 authentication with client callback integration for seamless single-page application authentication flows.  ## API Design v1.0.0  ### Authorization Model TMI uses hierarchical authorization: access control is defined at the ThreatModel level via the authorization field (readers, writers, owners). All child resources (Assets, Diagrams, Documents, Notes, Repositories, Threats) inherit permissions from their parent ThreatModel. This simplifies permission management and ensures consistent access control.  ### Bulk Operations Notes and Diagrams do not support bulk operations due to their unique creation workflows and lack of valid bulk use cases. All other resources (Threats, Assets, Documents, Repositories) support full bulk operations: POST (create), PUT (upsert), PATCH (partial update), DELETE (batch delete).  All resources support bulk metadata operations regardless of resource-level bulk support.  ### List Response Strategy - ThreatModels return summary information (TMListItem) because they contain many child objects that can be large. - Diagrams return summary information (DiagramListItem) because diagram data (cells, images) can be large. - Notes return summary information (NoteListItem) because the content field can be large. - Threats, Assets, Documents, Repositories return full schemas as they are relatively small and static.  ### PATCH Support All resources support PATCH for partial updates using JSON Patch (RFC 6902). This is particularly useful for: - Assets: Array field updates (affected_assets, trust_boundaries) ensuring no duplicates - Notes: Updating name/description without changing content field - All resources: Efficient updates without full object replacement 
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.Participant;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
/**
 * Details of an active collaboration session for a diagram
 */
@Schema(description = "Details of an active collaboration session for a diagram")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2025-11-01T19:29:35.350343762Z[GMT]")

public class CollaborationSession {
  @SerializedName("session_id")
  private UUID sessionId = null;

  @SerializedName("host")
  private String host = null;

  @SerializedName("presenter")
  private String presenter = null;

  @SerializedName("threat_model_id")
  private UUID threatModelId = null;

  @SerializedName("threat_model_name")
  private String threatModelName = null;

  @SerializedName("diagram_id")
  private UUID diagramId = null;

  @SerializedName("diagram_name")
  private String diagramName = null;

  @SerializedName("participants")
  private List<Participant> participants = new ArrayList<Participant>();

  @SerializedName("websocket_url")
  private String websocketUrl = null;

   /**
   * Unique identifier for the session (UUID)
   * @return sessionId
  **/
  @Schema(required = true, description = "Unique identifier for the session (UUID)")
  public UUID getSessionId() {
    return sessionId;
  }

   /**
   * Email address of the session host
   * @return host
  **/
  @Schema(required = true, description = "Email address of the session host")
  public String getHost() {
    return host;
  }

   /**
   * Email address of the current presenter
   * @return presenter
  **/
  @Schema(description = "Email address of the current presenter")
  public String getPresenter() {
    return presenter;
  }

  public CollaborationSession threatModelId(UUID threatModelId) {
    this.threatModelId = threatModelId;
    return this;
  }

   /**
   * Unique identifier of the associated threat model (UUID)
   * @return threatModelId
  **/
  @Schema(required = true, description = "Unique identifier of the associated threat model (UUID)")
  public UUID getThreatModelId() {
    return threatModelId;
  }

  public void setThreatModelId(UUID threatModelId) {
    this.threatModelId = threatModelId;
  }

  public CollaborationSession threatModelName(String threatModelName) {
    this.threatModelName = threatModelName;
    return this;
  }

   /**
   * Name of the associated threat model
   * @return threatModelName
  **/
  @Schema(required = true, description = "Name of the associated threat model")
  public String getThreatModelName() {
    return threatModelName;
  }

  public void setThreatModelName(String threatModelName) {
    this.threatModelName = threatModelName;
  }

  public CollaborationSession diagramId(UUID diagramId) {
    this.diagramId = diagramId;
    return this;
  }

   /**
   * Unique identifier of the associated diagram (UUID)
   * @return diagramId
  **/
  @Schema(required = true, description = "Unique identifier of the associated diagram (UUID)")
  public UUID getDiagramId() {
    return diagramId;
  }

  public void setDiagramId(UUID diagramId) {
    this.diagramId = diagramId;
  }

  public CollaborationSession diagramName(String diagramName) {
    this.diagramName = diagramName;
    return this;
  }

   /**
   * Name of the associated diagram
   * @return diagramName
  **/
  @Schema(required = true, description = "Name of the associated diagram")
  public String getDiagramName() {
    return diagramName;
  }

  public void setDiagramName(String diagramName) {
    this.diagramName = diagramName;
  }

  public CollaborationSession participants(List<Participant> participants) {
    this.participants = participants;
    return this;
  }

  public CollaborationSession addParticipantsItem(Participant participantsItem) {
    this.participants.add(participantsItem);
    return this;
  }

   /**
   * List of active participants
   * @return participants
  **/
  @Schema(required = true, description = "List of active participants")
  public List<Participant> getParticipants() {
    return participants;
  }

  public void setParticipants(List<Participant> participants) {
    this.participants = participants;
  }

  public CollaborationSession websocketUrl(String websocketUrl) {
    this.websocketUrl = websocketUrl;
    return this;
  }

   /**
   * WebSocket URL for real-time updates
   * @return websocketUrl
  **/
  @Schema(required = true, description = "WebSocket URL for real-time updates")
  public String getWebsocketUrl() {
    return websocketUrl;
  }

  public void setWebsocketUrl(String websocketUrl) {
    this.websocketUrl = websocketUrl;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CollaborationSession collaborationSession = (CollaborationSession) o;
    return Objects.equals(this.sessionId, collaborationSession.sessionId) &&
        Objects.equals(this.host, collaborationSession.host) &&
        Objects.equals(this.presenter, collaborationSession.presenter) &&
        Objects.equals(this.threatModelId, collaborationSession.threatModelId) &&
        Objects.equals(this.threatModelName, collaborationSession.threatModelName) &&
        Objects.equals(this.diagramId, collaborationSession.diagramId) &&
        Objects.equals(this.diagramName, collaborationSession.diagramName) &&
        Objects.equals(this.participants, collaborationSession.participants) &&
        Objects.equals(this.websocketUrl, collaborationSession.websocketUrl);
  }

  @Override
  public int hashCode() {
    return Objects.hash(sessionId, host, presenter, threatModelId, threatModelName, diagramId, diagramName, participants, websocketUrl);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CollaborationSession {\n");
    
    sb.append("    sessionId: ").append(toIndentedString(sessionId)).append("\n");
    sb.append("    host: ").append(toIndentedString(host)).append("\n");
    sb.append("    presenter: ").append(toIndentedString(presenter)).append("\n");
    sb.append("    threatModelId: ").append(toIndentedString(threatModelId)).append("\n");
    sb.append("    threatModelName: ").append(toIndentedString(threatModelName)).append("\n");
    sb.append("    diagramId: ").append(toIndentedString(diagramId)).append("\n");
    sb.append("    diagramName: ").append(toIndentedString(diagramName)).append("\n");
    sb.append("    participants: ").append(toIndentedString(participants)).append("\n");
    sb.append("    websocketUrl: ").append(toIndentedString(websocketUrl)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
