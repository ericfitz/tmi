# coding: utf-8

"""
    TMI (Threat Modeling Improved) API

    A RESTful API for collaborative threat modeling with full X6 graph library compatibility. This API provides schemas that align with AntV X6 cell object models for seamless integration with modern diagramming libraries. Supports OAuth 2.0 authentication with client callback integration for seamless single-page application authentication flows.  ## API Design v1.0.0  ### Authorization Model TMI uses hierarchical authorization: access control is defined at the ThreatModel level via the authorization field (readers, writers, owners). All child resources (Assets, Diagrams, Documents, Notes, Repositories, Threats) inherit permissions from their parent ThreatModel. This simplifies permission management and ensures consistent access control.  ### Bulk Operations Notes and Diagrams do not support bulk operations due to their unique creation workflows and lack of valid bulk use cases. All other resources (Threats, Assets, Documents, Repositories) support full bulk operations: POST (create), PUT (upsert), PATCH (partial update), DELETE (batch delete).  All resources support bulk metadata operations regardless of resource-level bulk support.  ### List Response Strategy - ThreatModels return summary information (TMListItem) because they contain many child objects that can be large. - Diagrams return summary information (DiagramListItem) because diagram data (cells, images) can be large. - Notes return summary information (NoteListItem) because the content field can be large. - Threats, Assets, Documents, Repositories return full schemas as they are relatively small and static.  ### PATCH Support All resources support PATCH for partial updates using JSON Patch (RFC 6902). This is particularly useful for: - Assets: Array field updates (affected_assets, trust_boundaries) ensuring no duplicates - Notes: Updating name/description without changing content field - All resources: Efficient updates without full object replacement   # noqa: E501

    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from tmi_client.api_client import ApiClient


class ThreatModelSubResourcesApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def bulk_create_diagram_metadata(self, body, threat_model_id, diagram_id, **kwargs):  # noqa: E501
        """Bulk create diagram metadata  # noqa: E501

        Creates multiple metadata entries in a single operation for the specified diagram  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_create_diagram_metadata(body, threat_model_id, diagram_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Metadata] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str diagram_id: Unique identifier of the diagram (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.bulk_create_diagram_metadata_with_http_info(body, threat_model_id, diagram_id, **kwargs)  # noqa: E501
        else:
            (data) = self.bulk_create_diagram_metadata_with_http_info(body, threat_model_id, diagram_id, **kwargs)  # noqa: E501
            return data

    def bulk_create_diagram_metadata_with_http_info(self, body, threat_model_id, diagram_id, **kwargs):  # noqa: E501
        """Bulk create diagram metadata  # noqa: E501

        Creates multiple metadata entries in a single operation for the specified diagram  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_create_diagram_metadata_with_http_info(body, threat_model_id, diagram_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Metadata] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str diagram_id: Unique identifier of the diagram (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'diagram_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_create_diagram_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `bulk_create_diagram_metadata`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `bulk_create_diagram_metadata`")  # noqa: E501
        # verify the required parameter 'diagram_id' is set
        if ('diagram_id' not in params or
                params['diagram_id'] is None):
            raise ValueError("Missing the required parameter `diagram_id` when calling `bulk_create_diagram_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'diagram_id' in params:
            path_params['diagram_id'] = params['diagram_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/diagrams/{diagram_id}/metadata/bulk', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Metadata]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def bulk_create_document_metadata(self, body, threat_model_id, document_id, **kwargs):  # noqa: E501
        """Bulk create document metadata  # noqa: E501

        Creates multiple metadata entries in a single operation for the specified document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_create_document_metadata(body, threat_model_id, document_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Metadata] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str document_id: Unique identifier of the document (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.bulk_create_document_metadata_with_http_info(body, threat_model_id, document_id, **kwargs)  # noqa: E501
        else:
            (data) = self.bulk_create_document_metadata_with_http_info(body, threat_model_id, document_id, **kwargs)  # noqa: E501
            return data

    def bulk_create_document_metadata_with_http_info(self, body, threat_model_id, document_id, **kwargs):  # noqa: E501
        """Bulk create document metadata  # noqa: E501

        Creates multiple metadata entries in a single operation for the specified document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_create_document_metadata_with_http_info(body, threat_model_id, document_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Metadata] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str document_id: Unique identifier of the document (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'document_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_create_document_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `bulk_create_document_metadata`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `bulk_create_document_metadata`")  # noqa: E501
        # verify the required parameter 'document_id' is set
        if ('document_id' not in params or
                params['document_id'] is None):
            raise ValueError("Missing the required parameter `document_id` when calling `bulk_create_document_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'document_id' in params:
            path_params['document_id'] = params['document_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/documents/{document_id}/metadata/bulk', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Metadata]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def bulk_create_note_metadata(self, body, threat_model_id, note_id, **kwargs):  # noqa: E501
        """Bulk create note metadata  # noqa: E501

        Creates multiple metadata key-value pairs for the specified note  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_create_note_metadata(body, threat_model_id, note_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Metadata] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str note_id: Unique identifier of the note (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.bulk_create_note_metadata_with_http_info(body, threat_model_id, note_id, **kwargs)  # noqa: E501
        else:
            (data) = self.bulk_create_note_metadata_with_http_info(body, threat_model_id, note_id, **kwargs)  # noqa: E501
            return data

    def bulk_create_note_metadata_with_http_info(self, body, threat_model_id, note_id, **kwargs):  # noqa: E501
        """Bulk create note metadata  # noqa: E501

        Creates multiple metadata key-value pairs for the specified note  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_create_note_metadata_with_http_info(body, threat_model_id, note_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Metadata] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str note_id: Unique identifier of the note (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'note_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_create_note_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `bulk_create_note_metadata`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `bulk_create_note_metadata`")  # noqa: E501
        # verify the required parameter 'note_id' is set
        if ('note_id' not in params or
                params['note_id'] is None):
            raise ValueError("Missing the required parameter `note_id` when calling `bulk_create_note_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'note_id' in params:
            path_params['note_id'] = params['note_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/notes/{note_id}/metadata/bulk', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Metadata]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def bulk_create_repository_metadata(self, body, threat_model_id, repository_id, **kwargs):  # noqa: E501
        """Bulk create source metadata  # noqa: E501

        Creates multiple metadata entries in a single operation for the specified source reference  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_create_repository_metadata(body, threat_model_id, repository_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Metadata] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str repository_id: Unique identifier of the source reference (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.bulk_create_repository_metadata_with_http_info(body, threat_model_id, repository_id, **kwargs)  # noqa: E501
        else:
            (data) = self.bulk_create_repository_metadata_with_http_info(body, threat_model_id, repository_id, **kwargs)  # noqa: E501
            return data

    def bulk_create_repository_metadata_with_http_info(self, body, threat_model_id, repository_id, **kwargs):  # noqa: E501
        """Bulk create source metadata  # noqa: E501

        Creates multiple metadata entries in a single operation for the specified source reference  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_create_repository_metadata_with_http_info(body, threat_model_id, repository_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Metadata] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str repository_id: Unique identifier of the source reference (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'repository_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_create_repository_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `bulk_create_repository_metadata`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `bulk_create_repository_metadata`")  # noqa: E501
        # verify the required parameter 'repository_id' is set
        if ('repository_id' not in params or
                params['repository_id'] is None):
            raise ValueError("Missing the required parameter `repository_id` when calling `bulk_create_repository_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'repository_id' in params:
            path_params['repository_id'] = params['repository_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/repositories/{repository_id}/metadata/bulk', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Metadata]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def bulk_create_threat_metadata(self, body, threat_model_id, threat_id, **kwargs):  # noqa: E501
        """Bulk create threat metadata  # noqa: E501

        Creates multiple metadata entries in a single operation for the specified threat  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_create_threat_metadata(body, threat_model_id, threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Metadata] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str threat_id: Unique identifier of the threat (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.bulk_create_threat_metadata_with_http_info(body, threat_model_id, threat_id, **kwargs)  # noqa: E501
        else:
            (data) = self.bulk_create_threat_metadata_with_http_info(body, threat_model_id, threat_id, **kwargs)  # noqa: E501
            return data

    def bulk_create_threat_metadata_with_http_info(self, body, threat_model_id, threat_id, **kwargs):  # noqa: E501
        """Bulk create threat metadata  # noqa: E501

        Creates multiple metadata entries in a single operation for the specified threat  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_create_threat_metadata_with_http_info(body, threat_model_id, threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Metadata] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str threat_id: Unique identifier of the threat (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'threat_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_create_threat_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `bulk_create_threat_metadata`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `bulk_create_threat_metadata`")  # noqa: E501
        # verify the required parameter 'threat_id' is set
        if ('threat_id' not in params or
                params['threat_id'] is None):
            raise ValueError("Missing the required parameter `threat_id` when calling `bulk_create_threat_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'threat_id' in params:
            path_params['threat_id'] = params['threat_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/threats/{threat_id}/metadata/bulk', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Metadata]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def bulk_create_threat_model_asset_metadata(self, body, threat_model_id, asset_id, **kwargs):  # noqa: E501
        """Bulk create asset metadata  # noqa: E501

        Creates multiple metadata key-value pairs for the specified asset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_create_threat_model_asset_metadata(body, threat_model_id, asset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Metadata] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str asset_id: Unique identifier of the asset (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.bulk_create_threat_model_asset_metadata_with_http_info(body, threat_model_id, asset_id, **kwargs)  # noqa: E501
        else:
            (data) = self.bulk_create_threat_model_asset_metadata_with_http_info(body, threat_model_id, asset_id, **kwargs)  # noqa: E501
            return data

    def bulk_create_threat_model_asset_metadata_with_http_info(self, body, threat_model_id, asset_id, **kwargs):  # noqa: E501
        """Bulk create asset metadata  # noqa: E501

        Creates multiple metadata key-value pairs for the specified asset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_create_threat_model_asset_metadata_with_http_info(body, threat_model_id, asset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Metadata] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str asset_id: Unique identifier of the asset (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'asset_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_create_threat_model_asset_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `bulk_create_threat_model_asset_metadata`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `bulk_create_threat_model_asset_metadata`")  # noqa: E501
        # verify the required parameter 'asset_id' is set
        if ('asset_id' not in params or
                params['asset_id'] is None):
            raise ValueError("Missing the required parameter `asset_id` when calling `bulk_create_threat_model_asset_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'asset_id' in params:
            path_params['asset_id'] = params['asset_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/assets/{asset_id}/metadata/bulk', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Metadata]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def bulk_create_threat_model_assets(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Bulk create assets  # noqa: E501

        Creates multiple assets within the specified threat model (maximum 50 per request)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_create_threat_model_assets(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Asset] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: list[Asset]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.bulk_create_threat_model_assets_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.bulk_create_threat_model_assets_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
            return data

    def bulk_create_threat_model_assets_with_http_info(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Bulk create assets  # noqa: E501

        Creates multiple assets within the specified threat model (maximum 50 per request)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_create_threat_model_assets_with_http_info(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Asset] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: list[Asset]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_create_threat_model_assets" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `bulk_create_threat_model_assets`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `bulk_create_threat_model_assets`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/assets/bulk', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Asset]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def bulk_create_threat_model_documents(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Bulk create documents  # noqa: E501

        Creates multiple documents in a single operation for the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_create_threat_model_documents(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Document] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: list[Document]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.bulk_create_threat_model_documents_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.bulk_create_threat_model_documents_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
            return data

    def bulk_create_threat_model_documents_with_http_info(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Bulk create documents  # noqa: E501

        Creates multiple documents in a single operation for the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_create_threat_model_documents_with_http_info(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Document] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: list[Document]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_create_threat_model_documents" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `bulk_create_threat_model_documents`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `bulk_create_threat_model_documents`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/documents/bulk', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Document]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def bulk_create_threat_model_metadata(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Bulk create threat model metadata  # noqa: E501

        Creates multiple metadata entries in a single operation for the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_create_threat_model_metadata(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Metadata] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.bulk_create_threat_model_metadata_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.bulk_create_threat_model_metadata_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
            return data

    def bulk_create_threat_model_metadata_with_http_info(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Bulk create threat model metadata  # noqa: E501

        Creates multiple metadata entries in a single operation for the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_create_threat_model_metadata_with_http_info(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Metadata] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_create_threat_model_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `bulk_create_threat_model_metadata`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `bulk_create_threat_model_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/metadata/bulk', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Metadata]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def bulk_create_threat_model_repositories(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Bulk create sources  # noqa: E501

        Creates multiple source references in a single operation for the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_create_threat_model_repositories(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Repository] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: list[Repository]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.bulk_create_threat_model_repositories_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.bulk_create_threat_model_repositories_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
            return data

    def bulk_create_threat_model_repositories_with_http_info(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Bulk create sources  # noqa: E501

        Creates multiple source references in a single operation for the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_create_threat_model_repositories_with_http_info(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Repository] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: list[Repository]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_create_threat_model_repositories" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `bulk_create_threat_model_repositories`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `bulk_create_threat_model_repositories`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/repositories/bulk', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Repository]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def bulk_create_threat_model_threats(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Bulk create threats  # noqa: E501

        Creates multiple threats in a single operation for the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_create_threat_model_threats(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Threat] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: list[Threat]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.bulk_create_threat_model_threats_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.bulk_create_threat_model_threats_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
            return data

    def bulk_create_threat_model_threats_with_http_info(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Bulk create threats  # noqa: E501

        Creates multiple threats in a single operation for the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_create_threat_model_threats_with_http_info(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Threat] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: list[Threat]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_create_threat_model_threats" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `bulk_create_threat_model_threats`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `bulk_create_threat_model_threats`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/threats/bulk', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Threat]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def bulk_update_note_metadata(self, body, threat_model_id, note_id, **kwargs):  # noqa: E501
        """Bulk update note metadata  # noqa: E501

        Updates multiple metadata entries for the specified note in a single operation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_update_note_metadata(body, threat_model_id, note_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Metadata] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str note_id: Unique identifier of the note (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.bulk_update_note_metadata_with_http_info(body, threat_model_id, note_id, **kwargs)  # noqa: E501
        else:
            (data) = self.bulk_update_note_metadata_with_http_info(body, threat_model_id, note_id, **kwargs)  # noqa: E501
            return data

    def bulk_update_note_metadata_with_http_info(self, body, threat_model_id, note_id, **kwargs):  # noqa: E501
        """Bulk update note metadata  # noqa: E501

        Updates multiple metadata entries for the specified note in a single operation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_update_note_metadata_with_http_info(body, threat_model_id, note_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Metadata] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str note_id: Unique identifier of the note (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'note_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_update_note_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `bulk_update_note_metadata`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `bulk_update_note_metadata`")  # noqa: E501
        # verify the required parameter 'note_id' is set
        if ('note_id' not in params or
                params['note_id'] is None):
            raise ValueError("Missing the required parameter `note_id` when calling `bulk_update_note_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'note_id' in params:
            path_params['note_id'] = params['note_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/notes/{note_id}/metadata/bulk', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Metadata]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def bulk_update_threat_model_threats(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Bulk update threats  # noqa: E501

        Updates multiple threats in a single operation for the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_update_threat_model_threats(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Threat] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: list[Threat]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.bulk_update_threat_model_threats_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.bulk_update_threat_model_threats_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
            return data

    def bulk_update_threat_model_threats_with_http_info(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Bulk update threats  # noqa: E501

        Updates multiple threats in a single operation for the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_update_threat_model_threats_with_http_info(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Threat] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: list[Threat]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_update_threat_model_threats" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `bulk_update_threat_model_threats`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `bulk_update_threat_model_threats`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/threats/bulk', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Threat]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def bulk_upsert_diagram_metadata(self, body, threat_model_id, diagram_id, **kwargs):  # noqa: E501
        """Bulk upsert diagram metadata  # noqa: E501

        Creates or updates multiple metadata key-value pairs for the specified diagram  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_upsert_diagram_metadata(body, threat_model_id, diagram_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Metadata] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str diagram_id: Unique identifier of the diagram (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.bulk_upsert_diagram_metadata_with_http_info(body, threat_model_id, diagram_id, **kwargs)  # noqa: E501
        else:
            (data) = self.bulk_upsert_diagram_metadata_with_http_info(body, threat_model_id, diagram_id, **kwargs)  # noqa: E501
            return data

    def bulk_upsert_diagram_metadata_with_http_info(self, body, threat_model_id, diagram_id, **kwargs):  # noqa: E501
        """Bulk upsert diagram metadata  # noqa: E501

        Creates or updates multiple metadata key-value pairs for the specified diagram  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_upsert_diagram_metadata_with_http_info(body, threat_model_id, diagram_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Metadata] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str diagram_id: Unique identifier of the diagram (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'diagram_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_upsert_diagram_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `bulk_upsert_diagram_metadata`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `bulk_upsert_diagram_metadata`")  # noqa: E501
        # verify the required parameter 'diagram_id' is set
        if ('diagram_id' not in params or
                params['diagram_id'] is None):
            raise ValueError("Missing the required parameter `diagram_id` when calling `bulk_upsert_diagram_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'diagram_id' in params:
            path_params['diagram_id'] = params['diagram_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/diagrams/{diagram_id}/metadata/bulk', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Metadata]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def bulk_upsert_document_metadata(self, body, threat_model_id, document_id, **kwargs):  # noqa: E501
        """Bulk upsert document metadata  # noqa: E501

        Creates or updates multiple metadata key-value pairs for the specified document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_upsert_document_metadata(body, threat_model_id, document_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Metadata] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str document_id: Unique identifier of the document (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.bulk_upsert_document_metadata_with_http_info(body, threat_model_id, document_id, **kwargs)  # noqa: E501
        else:
            (data) = self.bulk_upsert_document_metadata_with_http_info(body, threat_model_id, document_id, **kwargs)  # noqa: E501
            return data

    def bulk_upsert_document_metadata_with_http_info(self, body, threat_model_id, document_id, **kwargs):  # noqa: E501
        """Bulk upsert document metadata  # noqa: E501

        Creates or updates multiple metadata key-value pairs for the specified document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_upsert_document_metadata_with_http_info(body, threat_model_id, document_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Metadata] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str document_id: Unique identifier of the document (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'document_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_upsert_document_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `bulk_upsert_document_metadata`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `bulk_upsert_document_metadata`")  # noqa: E501
        # verify the required parameter 'document_id' is set
        if ('document_id' not in params or
                params['document_id'] is None):
            raise ValueError("Missing the required parameter `document_id` when calling `bulk_upsert_document_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'document_id' in params:
            path_params['document_id'] = params['document_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/documents/{document_id}/metadata/bulk', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Metadata]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def bulk_upsert_repository_metadata(self, body, threat_model_id, repository_id, **kwargs):  # noqa: E501
        """Bulk upsert repository metadata  # noqa: E501

        Creates or updates multiple metadata key-value pairs for the specified repository  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_upsert_repository_metadata(body, threat_model_id, repository_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Metadata] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str repository_id: Unique identifier of the source reference (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.bulk_upsert_repository_metadata_with_http_info(body, threat_model_id, repository_id, **kwargs)  # noqa: E501
        else:
            (data) = self.bulk_upsert_repository_metadata_with_http_info(body, threat_model_id, repository_id, **kwargs)  # noqa: E501
            return data

    def bulk_upsert_repository_metadata_with_http_info(self, body, threat_model_id, repository_id, **kwargs):  # noqa: E501
        """Bulk upsert repository metadata  # noqa: E501

        Creates or updates multiple metadata key-value pairs for the specified repository  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_upsert_repository_metadata_with_http_info(body, threat_model_id, repository_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Metadata] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str repository_id: Unique identifier of the source reference (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'repository_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_upsert_repository_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `bulk_upsert_repository_metadata`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `bulk_upsert_repository_metadata`")  # noqa: E501
        # verify the required parameter 'repository_id' is set
        if ('repository_id' not in params or
                params['repository_id'] is None):
            raise ValueError("Missing the required parameter `repository_id` when calling `bulk_upsert_repository_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'repository_id' in params:
            path_params['repository_id'] = params['repository_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/repositories/{repository_id}/metadata/bulk', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Metadata]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def bulk_upsert_threat_metadata(self, body, threat_model_id, threat_id, **kwargs):  # noqa: E501
        """Bulk upsert threat metadata  # noqa: E501

        Creates or updates multiple metadata key-value pairs for the specified threat  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_upsert_threat_metadata(body, threat_model_id, threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Metadata] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str threat_id: Unique identifier of the threat (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.bulk_upsert_threat_metadata_with_http_info(body, threat_model_id, threat_id, **kwargs)  # noqa: E501
        else:
            (data) = self.bulk_upsert_threat_metadata_with_http_info(body, threat_model_id, threat_id, **kwargs)  # noqa: E501
            return data

    def bulk_upsert_threat_metadata_with_http_info(self, body, threat_model_id, threat_id, **kwargs):  # noqa: E501
        """Bulk upsert threat metadata  # noqa: E501

        Creates or updates multiple metadata key-value pairs for the specified threat  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_upsert_threat_metadata_with_http_info(body, threat_model_id, threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Metadata] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str threat_id: Unique identifier of the threat (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'threat_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_upsert_threat_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `bulk_upsert_threat_metadata`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `bulk_upsert_threat_metadata`")  # noqa: E501
        # verify the required parameter 'threat_id' is set
        if ('threat_id' not in params or
                params['threat_id'] is None):
            raise ValueError("Missing the required parameter `threat_id` when calling `bulk_upsert_threat_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'threat_id' in params:
            path_params['threat_id'] = params['threat_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/threats/{threat_id}/metadata/bulk', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Metadata]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def bulk_upsert_threat_model_asset_metadata(self, body, threat_model_id, asset_id, **kwargs):  # noqa: E501
        """Bulk upsert asset metadata  # noqa: E501

        Creates or updates multiple metadata key-value pairs for the specified asset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_upsert_threat_model_asset_metadata(body, threat_model_id, asset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Metadata] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str asset_id: Unique identifier of the asset (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.bulk_upsert_threat_model_asset_metadata_with_http_info(body, threat_model_id, asset_id, **kwargs)  # noqa: E501
        else:
            (data) = self.bulk_upsert_threat_model_asset_metadata_with_http_info(body, threat_model_id, asset_id, **kwargs)  # noqa: E501
            return data

    def bulk_upsert_threat_model_asset_metadata_with_http_info(self, body, threat_model_id, asset_id, **kwargs):  # noqa: E501
        """Bulk upsert asset metadata  # noqa: E501

        Creates or updates multiple metadata key-value pairs for the specified asset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_upsert_threat_model_asset_metadata_with_http_info(body, threat_model_id, asset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Metadata] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str asset_id: Unique identifier of the asset (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'asset_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_upsert_threat_model_asset_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `bulk_upsert_threat_model_asset_metadata`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `bulk_upsert_threat_model_asset_metadata`")  # noqa: E501
        # verify the required parameter 'asset_id' is set
        if ('asset_id' not in params or
                params['asset_id'] is None):
            raise ValueError("Missing the required parameter `asset_id` when calling `bulk_upsert_threat_model_asset_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'asset_id' in params:
            path_params['asset_id'] = params['asset_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/assets/{asset_id}/metadata/bulk', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Metadata]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def bulk_upsert_threat_model_assets(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Bulk upsert assets  # noqa: E501

        Create or update multiple assets in a single request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_upsert_threat_model_assets(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Asset] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: list[Asset]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.bulk_upsert_threat_model_assets_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.bulk_upsert_threat_model_assets_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
            return data

    def bulk_upsert_threat_model_assets_with_http_info(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Bulk upsert assets  # noqa: E501

        Create or update multiple assets in a single request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_upsert_threat_model_assets_with_http_info(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Asset] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: list[Asset]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_upsert_threat_model_assets" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `bulk_upsert_threat_model_assets`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `bulk_upsert_threat_model_assets`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/assets/bulk', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Asset]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def bulk_upsert_threat_model_documents(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Bulk upsert documents  # noqa: E501

        Create or update multiple documents in a single request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_upsert_threat_model_documents(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Document] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: list[Document]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.bulk_upsert_threat_model_documents_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.bulk_upsert_threat_model_documents_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
            return data

    def bulk_upsert_threat_model_documents_with_http_info(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Bulk upsert documents  # noqa: E501

        Create or update multiple documents in a single request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_upsert_threat_model_documents_with_http_info(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Document] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: list[Document]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_upsert_threat_model_documents" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `bulk_upsert_threat_model_documents`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `bulk_upsert_threat_model_documents`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/documents/bulk', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Document]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def bulk_upsert_threat_model_metadata(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Bulk upsert threat model metadata  # noqa: E501

        Creates or updates multiple metadata key-value pairs for the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_upsert_threat_model_metadata(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Metadata] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.bulk_upsert_threat_model_metadata_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.bulk_upsert_threat_model_metadata_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
            return data

    def bulk_upsert_threat_model_metadata_with_http_info(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Bulk upsert threat model metadata  # noqa: E501

        Creates or updates multiple metadata key-value pairs for the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_upsert_threat_model_metadata_with_http_info(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Metadata] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_upsert_threat_model_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `bulk_upsert_threat_model_metadata`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `bulk_upsert_threat_model_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/metadata/bulk', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Metadata]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def bulk_upsert_threat_model_repositories(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Bulk upsert repositories  # noqa: E501

        Create or update multiple repositories in a single request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_upsert_threat_model_repositories(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Repository] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: list[Repository]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.bulk_upsert_threat_model_repositories_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.bulk_upsert_threat_model_repositories_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
            return data

    def bulk_upsert_threat_model_repositories_with_http_info(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Bulk upsert repositories  # noqa: E501

        Create or update multiple repositories in a single request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_upsert_threat_model_repositories_with_http_info(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[Repository] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: list[Repository]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_upsert_threat_model_repositories" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `bulk_upsert_threat_model_repositories`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `bulk_upsert_threat_model_repositories`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/repositories/bulk', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Repository]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_diagram_metadata(self, body, threat_model_id, diagram_id, **kwargs):  # noqa: E501
        """Create diagram metadata  # noqa: E501

        Creates a new metadata entry for the specified diagram  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_diagram_metadata(body, threat_model_id, diagram_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Metadata body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str diagram_id: Unique identifier of the diagram (UUID) (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_diagram_metadata_with_http_info(body, threat_model_id, diagram_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_diagram_metadata_with_http_info(body, threat_model_id, diagram_id, **kwargs)  # noqa: E501
            return data

    def create_diagram_metadata_with_http_info(self, body, threat_model_id, diagram_id, **kwargs):  # noqa: E501
        """Create diagram metadata  # noqa: E501

        Creates a new metadata entry for the specified diagram  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_diagram_metadata_with_http_info(body, threat_model_id, diagram_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Metadata body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str diagram_id: Unique identifier of the diagram (UUID) (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'diagram_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_diagram_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_diagram_metadata`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `create_diagram_metadata`")  # noqa: E501
        # verify the required parameter 'diagram_id' is set
        if ('diagram_id' not in params or
                params['diagram_id'] is None):
            raise ValueError("Missing the required parameter `diagram_id` when calling `create_diagram_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'diagram_id' in params:
            path_params['diagram_id'] = params['diagram_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/diagrams/{diagram_id}/metadata', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Metadata',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_document_metadata(self, body, threat_model_id, document_id, **kwargs):  # noqa: E501
        """Create document metadata  # noqa: E501

        Creates new metadata entry for the specified document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_document_metadata(body, threat_model_id, document_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Metadata body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str document_id: Unique identifier of the document (UUID) (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_document_metadata_with_http_info(body, threat_model_id, document_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_document_metadata_with_http_info(body, threat_model_id, document_id, **kwargs)  # noqa: E501
            return data

    def create_document_metadata_with_http_info(self, body, threat_model_id, document_id, **kwargs):  # noqa: E501
        """Create document metadata  # noqa: E501

        Creates new metadata entry for the specified document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_document_metadata_with_http_info(body, threat_model_id, document_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Metadata body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str document_id: Unique identifier of the document (UUID) (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'document_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_document_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_document_metadata`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `create_document_metadata`")  # noqa: E501
        # verify the required parameter 'document_id' is set
        if ('document_id' not in params or
                params['document_id'] is None):
            raise ValueError("Missing the required parameter `document_id` when calling `create_document_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'document_id' in params:
            path_params['document_id'] = params['document_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/documents/{document_id}/metadata', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Metadata',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_note_metadata(self, body, threat_model_id, note_id, **kwargs):  # noqa: E501
        """Create note metadata  # noqa: E501

        Creates new metadata entry for the specified note  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_note_metadata(body, threat_model_id, note_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Metadata body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str note_id: Unique identifier of the note (UUID) (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_note_metadata_with_http_info(body, threat_model_id, note_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_note_metadata_with_http_info(body, threat_model_id, note_id, **kwargs)  # noqa: E501
            return data

    def create_note_metadata_with_http_info(self, body, threat_model_id, note_id, **kwargs):  # noqa: E501
        """Create note metadata  # noqa: E501

        Creates new metadata entry for the specified note  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_note_metadata_with_http_info(body, threat_model_id, note_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Metadata body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str note_id: Unique identifier of the note (UUID) (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'note_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_note_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_note_metadata`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `create_note_metadata`")  # noqa: E501
        # verify the required parameter 'note_id' is set
        if ('note_id' not in params or
                params['note_id'] is None):
            raise ValueError("Missing the required parameter `note_id` when calling `create_note_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'note_id' in params:
            path_params['note_id'] = params['note_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/notes/{note_id}/metadata', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Metadata',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_repository_metadata(self, body, threat_model_id, repository_id, **kwargs):  # noqa: E501
        """Create source metadata  # noqa: E501

        Creates new metadata entry for the specified source reference  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_repository_metadata(body, threat_model_id, repository_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Metadata body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str repository_id: Unique identifier of the source reference (UUID) (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_repository_metadata_with_http_info(body, threat_model_id, repository_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_repository_metadata_with_http_info(body, threat_model_id, repository_id, **kwargs)  # noqa: E501
            return data

    def create_repository_metadata_with_http_info(self, body, threat_model_id, repository_id, **kwargs):  # noqa: E501
        """Create source metadata  # noqa: E501

        Creates new metadata entry for the specified source reference  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_repository_metadata_with_http_info(body, threat_model_id, repository_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Metadata body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str repository_id: Unique identifier of the source reference (UUID) (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'repository_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_repository_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_repository_metadata`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `create_repository_metadata`")  # noqa: E501
        # verify the required parameter 'repository_id' is set
        if ('repository_id' not in params or
                params['repository_id'] is None):
            raise ValueError("Missing the required parameter `repository_id` when calling `create_repository_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'repository_id' in params:
            path_params['repository_id'] = params['repository_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/repositories/{repository_id}/metadata', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Metadata',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_threat_metadata(self, body, threat_model_id, threat_id, **kwargs):  # noqa: E501
        """Create threat metadata  # noqa: E501

        Creates new metadata entry for the specified threat  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_threat_metadata(body, threat_model_id, threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Metadata body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str threat_id: Unique identifier of the threat (UUID) (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_threat_metadata_with_http_info(body, threat_model_id, threat_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_threat_metadata_with_http_info(body, threat_model_id, threat_id, **kwargs)  # noqa: E501
            return data

    def create_threat_metadata_with_http_info(self, body, threat_model_id, threat_id, **kwargs):  # noqa: E501
        """Create threat metadata  # noqa: E501

        Creates new metadata entry for the specified threat  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_threat_metadata_with_http_info(body, threat_model_id, threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Metadata body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str threat_id: Unique identifier of the threat (UUID) (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'threat_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_threat_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_threat_metadata`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `create_threat_metadata`")  # noqa: E501
        # verify the required parameter 'threat_id' is set
        if ('threat_id' not in params or
                params['threat_id'] is None):
            raise ValueError("Missing the required parameter `threat_id` when calling `create_threat_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'threat_id' in params:
            path_params['threat_id'] = params['threat_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/threats/{threat_id}/metadata', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Metadata',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_threat_model_asset(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Create a new asset  # noqa: E501

        Creates a new asset within the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_threat_model_asset(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AssetInput body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: Asset
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_threat_model_asset_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_threat_model_asset_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
            return data

    def create_threat_model_asset_with_http_info(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Create a new asset  # noqa: E501

        Creates a new asset within the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_threat_model_asset_with_http_info(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AssetInput body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: Asset
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_threat_model_asset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_threat_model_asset`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `create_threat_model_asset`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/assets', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Asset',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_threat_model_asset_metadata(self, body, threat_model_id, asset_id, **kwargs):  # noqa: E501
        """Add metadata to an asset  # noqa: E501

        Adds a new metadata key-value pair to the specified asset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_threat_model_asset_metadata(body, threat_model_id, asset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Metadata body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str asset_id: Unique identifier of the asset (UUID) (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_threat_model_asset_metadata_with_http_info(body, threat_model_id, asset_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_threat_model_asset_metadata_with_http_info(body, threat_model_id, asset_id, **kwargs)  # noqa: E501
            return data

    def create_threat_model_asset_metadata_with_http_info(self, body, threat_model_id, asset_id, **kwargs):  # noqa: E501
        """Add metadata to an asset  # noqa: E501

        Adds a new metadata key-value pair to the specified asset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_threat_model_asset_metadata_with_http_info(body, threat_model_id, asset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Metadata body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str asset_id: Unique identifier of the asset (UUID) (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'asset_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_threat_model_asset_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_threat_model_asset_metadata`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `create_threat_model_asset_metadata`")  # noqa: E501
        # verify the required parameter 'asset_id' is set
        if ('asset_id' not in params or
                params['asset_id'] is None):
            raise ValueError("Missing the required parameter `asset_id` when calling `create_threat_model_asset_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'asset_id' in params:
            path_params['asset_id'] = params['asset_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/assets/{asset_id}/metadata', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Metadata',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_threat_model_diagram(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Create a new diagram  # noqa: E501

        Creates a new diagram within the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_threat_model_diagram(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateDiagramRequest body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: Diagram
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_threat_model_diagram_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_threat_model_diagram_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
            return data

    def create_threat_model_diagram_with_http_info(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Create a new diagram  # noqa: E501

        Creates a new diagram within the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_threat_model_diagram_with_http_info(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateDiagramRequest body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: Diagram
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_threat_model_diagram" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_threat_model_diagram`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `create_threat_model_diagram`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/diagrams', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Diagram',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_threat_model_document(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Create a new document  # noqa: E501

        Creates a new document within the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_threat_model_document(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DocumentInput body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: Document
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_threat_model_document_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_threat_model_document_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
            return data

    def create_threat_model_document_with_http_info(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Create a new document  # noqa: E501

        Creates a new document within the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_threat_model_document_with_http_info(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DocumentInput body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: Document
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_threat_model_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_threat_model_document`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `create_threat_model_document`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/documents', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Document',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_threat_model_metadata(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Create threat model metadata  # noqa: E501

        Creates new metadata entry for the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_threat_model_metadata(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Metadata body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_threat_model_metadata_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_threat_model_metadata_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
            return data

    def create_threat_model_metadata_with_http_info(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Create threat model metadata  # noqa: E501

        Creates new metadata entry for the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_threat_model_metadata_with_http_info(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Metadata body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_threat_model_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_threat_model_metadata`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `create_threat_model_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/metadata', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Metadata',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_threat_model_note(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Create a new note  # noqa: E501

        Creates a new note within the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_threat_model_note(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NoteInput body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: Note
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_threat_model_note_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_threat_model_note_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
            return data

    def create_threat_model_note_with_http_info(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Create a new note  # noqa: E501

        Creates a new note within the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_threat_model_note_with_http_info(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NoteInput body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: Note
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_threat_model_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_threat_model_note`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `create_threat_model_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/notes', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Note',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_threat_model_repository(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Create a new source reference  # noqa: E501

        Creates a new source code reference within the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_threat_model_repository(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RepositoryInput body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: Repository
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_threat_model_repository_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_threat_model_repository_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
            return data

    def create_threat_model_repository_with_http_info(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Create a new source reference  # noqa: E501

        Creates a new source code reference within the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_threat_model_repository_with_http_info(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RepositoryInput body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: Repository
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_threat_model_repository" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_threat_model_repository`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `create_threat_model_repository`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/repositories', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Repository',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_threat_model_threat(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Create a new threat  # noqa: E501

        Creates a new threat within the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_threat_model_threat(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ThreatInput body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: Threat
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_threat_model_threat_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_threat_model_threat_with_http_info(body, threat_model_id, **kwargs)  # noqa: E501
            return data

    def create_threat_model_threat_with_http_info(self, body, threat_model_id, **kwargs):  # noqa: E501
        """Create a new threat  # noqa: E501

        Creates a new threat within the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_threat_model_threat_with_http_info(body, threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ThreatInput body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: Threat
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_threat_model_threat" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_threat_model_threat`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `create_threat_model_threat`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/threats', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Threat',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_diagram_metadata_by_key(self, threat_model_id, diagram_id, key, **kwargs):  # noqa: E501
        """Delete diagram metadata by key  # noqa: E501

        Removes a specific metadata entry for the diagram by key  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_diagram_metadata_by_key(threat_model_id, diagram_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str diagram_id: Unique identifier of the diagram (UUID) (required)
        :param str key: Metadata key to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_diagram_metadata_by_key_with_http_info(threat_model_id, diagram_id, key, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_diagram_metadata_by_key_with_http_info(threat_model_id, diagram_id, key, **kwargs)  # noqa: E501
            return data

    def delete_diagram_metadata_by_key_with_http_info(self, threat_model_id, diagram_id, key, **kwargs):  # noqa: E501
        """Delete diagram metadata by key  # noqa: E501

        Removes a specific metadata entry for the diagram by key  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_diagram_metadata_by_key_with_http_info(threat_model_id, diagram_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str diagram_id: Unique identifier of the diagram (UUID) (required)
        :param str key: Metadata key to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'diagram_id', 'key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_diagram_metadata_by_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `delete_diagram_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'diagram_id' is set
        if ('diagram_id' not in params or
                params['diagram_id'] is None):
            raise ValueError("Missing the required parameter `diagram_id` when calling `delete_diagram_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'key' is set
        if ('key' not in params or
                params['key'] is None):
            raise ValueError("Missing the required parameter `key` when calling `delete_diagram_metadata_by_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'diagram_id' in params:
            path_params['diagram_id'] = params['diagram_id']  # noqa: E501
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/diagrams/{diagram_id}/metadata/{key}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_document_metadata_by_key(self, threat_model_id, document_id, key, **kwargs):  # noqa: E501
        """Delete document metadata by key  # noqa: E501

        Deletes a specific metadata entry by key for the specified document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_document_metadata_by_key(threat_model_id, document_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str document_id: Unique identifier of the document (UUID) (required)
        :param str key: Metadata key to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_document_metadata_by_key_with_http_info(threat_model_id, document_id, key, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_document_metadata_by_key_with_http_info(threat_model_id, document_id, key, **kwargs)  # noqa: E501
            return data

    def delete_document_metadata_by_key_with_http_info(self, threat_model_id, document_id, key, **kwargs):  # noqa: E501
        """Delete document metadata by key  # noqa: E501

        Deletes a specific metadata entry by key for the specified document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_document_metadata_by_key_with_http_info(threat_model_id, document_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str document_id: Unique identifier of the document (UUID) (required)
        :param str key: Metadata key to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'document_id', 'key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_document_metadata_by_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `delete_document_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'document_id' is set
        if ('document_id' not in params or
                params['document_id'] is None):
            raise ValueError("Missing the required parameter `document_id` when calling `delete_document_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'key' is set
        if ('key' not in params or
                params['key'] is None):
            raise ValueError("Missing the required parameter `key` when calling `delete_document_metadata_by_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'document_id' in params:
            path_params['document_id'] = params['document_id']  # noqa: E501
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/documents/{document_id}/metadata/{key}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_note_metadata_by_key(self, threat_model_id, note_id, key, **kwargs):  # noqa: E501
        """Delete note metadata by key  # noqa: E501

        Deletes a specific metadata entry by key for the specified note  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_note_metadata_by_key(threat_model_id, note_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str note_id: Unique identifier of the note (UUID) (required)
        :param str key: Metadata key to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_note_metadata_by_key_with_http_info(threat_model_id, note_id, key, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_note_metadata_by_key_with_http_info(threat_model_id, note_id, key, **kwargs)  # noqa: E501
            return data

    def delete_note_metadata_by_key_with_http_info(self, threat_model_id, note_id, key, **kwargs):  # noqa: E501
        """Delete note metadata by key  # noqa: E501

        Deletes a specific metadata entry by key for the specified note  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_note_metadata_by_key_with_http_info(threat_model_id, note_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str note_id: Unique identifier of the note (UUID) (required)
        :param str key: Metadata key to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'note_id', 'key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_note_metadata_by_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `delete_note_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'note_id' is set
        if ('note_id' not in params or
                params['note_id'] is None):
            raise ValueError("Missing the required parameter `note_id` when calling `delete_note_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'key' is set
        if ('key' not in params or
                params['key'] is None):
            raise ValueError("Missing the required parameter `key` when calling `delete_note_metadata_by_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'note_id' in params:
            path_params['note_id'] = params['note_id']  # noqa: E501
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/notes/{note_id}/metadata/{key}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_repository_metadata_by_key(self, threat_model_id, repository_id, key, **kwargs):  # noqa: E501
        """Delete source metadata by key  # noqa: E501

        Deletes a specific metadata entry by key for the specified source reference  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_repository_metadata_by_key(threat_model_id, repository_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str repository_id: Unique identifier of the source reference (UUID) (required)
        :param str key: Metadata key to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_repository_metadata_by_key_with_http_info(threat_model_id, repository_id, key, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_repository_metadata_by_key_with_http_info(threat_model_id, repository_id, key, **kwargs)  # noqa: E501
            return data

    def delete_repository_metadata_by_key_with_http_info(self, threat_model_id, repository_id, key, **kwargs):  # noqa: E501
        """Delete source metadata by key  # noqa: E501

        Deletes a specific metadata entry by key for the specified source reference  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_repository_metadata_by_key_with_http_info(threat_model_id, repository_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str repository_id: Unique identifier of the source reference (UUID) (required)
        :param str key: Metadata key to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'repository_id', 'key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_repository_metadata_by_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `delete_repository_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'repository_id' is set
        if ('repository_id' not in params or
                params['repository_id'] is None):
            raise ValueError("Missing the required parameter `repository_id` when calling `delete_repository_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'key' is set
        if ('key' not in params or
                params['key'] is None):
            raise ValueError("Missing the required parameter `key` when calling `delete_repository_metadata_by_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'repository_id' in params:
            path_params['repository_id'] = params['repository_id']  # noqa: E501
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/repositories/{repository_id}/metadata/{key}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_threat_metadata_by_key(self, threat_model_id, threat_id, key, **kwargs):  # noqa: E501
        """Delete threat metadata by key  # noqa: E501

        Deletes a specific metadata entry by key for the specified threat  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_threat_metadata_by_key(threat_model_id, threat_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str threat_id: Unique identifier of the threat (UUID) (required)
        :param str key: Metadata key to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_threat_metadata_by_key_with_http_info(threat_model_id, threat_id, key, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_threat_metadata_by_key_with_http_info(threat_model_id, threat_id, key, **kwargs)  # noqa: E501
            return data

    def delete_threat_metadata_by_key_with_http_info(self, threat_model_id, threat_id, key, **kwargs):  # noqa: E501
        """Delete threat metadata by key  # noqa: E501

        Deletes a specific metadata entry by key for the specified threat  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_threat_metadata_by_key_with_http_info(threat_model_id, threat_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str threat_id: Unique identifier of the threat (UUID) (required)
        :param str key: Metadata key to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'threat_id', 'key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_threat_metadata_by_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `delete_threat_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'threat_id' is set
        if ('threat_id' not in params or
                params['threat_id'] is None):
            raise ValueError("Missing the required parameter `threat_id` when calling `delete_threat_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'key' is set
        if ('key' not in params or
                params['key'] is None):
            raise ValueError("Missing the required parameter `key` when calling `delete_threat_metadata_by_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'threat_id' in params:
            path_params['threat_id'] = params['threat_id']  # noqa: E501
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/threats/{threat_id}/metadata/{key}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_threat_model_asset(self, threat_model_id, asset_id, **kwargs):  # noqa: E501
        """Delete an asset  # noqa: E501

        Deletes an asset from the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_threat_model_asset(threat_model_id, asset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str asset_id: Unique identifier of the asset (UUID) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_threat_model_asset_with_http_info(threat_model_id, asset_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_threat_model_asset_with_http_info(threat_model_id, asset_id, **kwargs)  # noqa: E501
            return data

    def delete_threat_model_asset_with_http_info(self, threat_model_id, asset_id, **kwargs):  # noqa: E501
        """Delete an asset  # noqa: E501

        Deletes an asset from the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_threat_model_asset_with_http_info(threat_model_id, asset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str asset_id: Unique identifier of the asset (UUID) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'asset_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_threat_model_asset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `delete_threat_model_asset`")  # noqa: E501
        # verify the required parameter 'asset_id' is set
        if ('asset_id' not in params or
                params['asset_id'] is None):
            raise ValueError("Missing the required parameter `asset_id` when calling `delete_threat_model_asset`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'asset_id' in params:
            path_params['asset_id'] = params['asset_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/assets/{asset_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_threat_model_asset_metadata(self, threat_model_id, asset_id, key, **kwargs):  # noqa: E501
        """Delete asset metadata  # noqa: E501

        Deletes a metadata key-value pair from the specified asset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_threat_model_asset_metadata(threat_model_id, asset_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str asset_id: Unique identifier of the asset (UUID) (required)
        :param str key: Metadata key (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_threat_model_asset_metadata_with_http_info(threat_model_id, asset_id, key, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_threat_model_asset_metadata_with_http_info(threat_model_id, asset_id, key, **kwargs)  # noqa: E501
            return data

    def delete_threat_model_asset_metadata_with_http_info(self, threat_model_id, asset_id, key, **kwargs):  # noqa: E501
        """Delete asset metadata  # noqa: E501

        Deletes a metadata key-value pair from the specified asset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_threat_model_asset_metadata_with_http_info(threat_model_id, asset_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str asset_id: Unique identifier of the asset (UUID) (required)
        :param str key: Metadata key (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'asset_id', 'key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_threat_model_asset_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `delete_threat_model_asset_metadata`")  # noqa: E501
        # verify the required parameter 'asset_id' is set
        if ('asset_id' not in params or
                params['asset_id'] is None):
            raise ValueError("Missing the required parameter `asset_id` when calling `delete_threat_model_asset_metadata`")  # noqa: E501
        # verify the required parameter 'key' is set
        if ('key' not in params or
                params['key'] is None):
            raise ValueError("Missing the required parameter `key` when calling `delete_threat_model_asset_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'asset_id' in params:
            path_params['asset_id'] = params['asset_id']  # noqa: E501
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/assets/{asset_id}/metadata/{key}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_threat_model_diagram(self, threat_model_id, diagram_id, **kwargs):  # noqa: E501
        """Delete a diagram  # noqa: E501

        Permanently removes a diagram from the threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_threat_model_diagram(threat_model_id, diagram_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str diagram_id: Unique identifier of the diagram (UUID) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_threat_model_diagram_with_http_info(threat_model_id, diagram_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_threat_model_diagram_with_http_info(threat_model_id, diagram_id, **kwargs)  # noqa: E501
            return data

    def delete_threat_model_diagram_with_http_info(self, threat_model_id, diagram_id, **kwargs):  # noqa: E501
        """Delete a diagram  # noqa: E501

        Permanently removes a diagram from the threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_threat_model_diagram_with_http_info(threat_model_id, diagram_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str diagram_id: Unique identifier of the diagram (UUID) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'diagram_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_threat_model_diagram" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `delete_threat_model_diagram`")  # noqa: E501
        # verify the required parameter 'diagram_id' is set
        if ('diagram_id' not in params or
                params['diagram_id'] is None):
            raise ValueError("Missing the required parameter `diagram_id` when calling `delete_threat_model_diagram`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'diagram_id' in params:
            path_params['diagram_id'] = params['diagram_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/diagrams/{diagram_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_threat_model_document(self, threat_model_id, document_id, **kwargs):  # noqa: E501
        """Delete a document  # noqa: E501

        Deletes a specific document from the threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_threat_model_document(threat_model_id, document_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str document_id: Unique identifier of the document (UUID) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_threat_model_document_with_http_info(threat_model_id, document_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_threat_model_document_with_http_info(threat_model_id, document_id, **kwargs)  # noqa: E501
            return data

    def delete_threat_model_document_with_http_info(self, threat_model_id, document_id, **kwargs):  # noqa: E501
        """Delete a document  # noqa: E501

        Deletes a specific document from the threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_threat_model_document_with_http_info(threat_model_id, document_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str document_id: Unique identifier of the document (UUID) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'document_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_threat_model_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `delete_threat_model_document`")  # noqa: E501
        # verify the required parameter 'document_id' is set
        if ('document_id' not in params or
                params['document_id'] is None):
            raise ValueError("Missing the required parameter `document_id` when calling `delete_threat_model_document`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'document_id' in params:
            path_params['document_id'] = params['document_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/documents/{document_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_threat_model_metadata_by_key(self, threat_model_id, key, **kwargs):  # noqa: E501
        """Delete threat model metadata by key  # noqa: E501

        Deletes a specific metadata entry by key for the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_threat_model_metadata_by_key(threat_model_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str key: Metadata key to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_threat_model_metadata_by_key_with_http_info(threat_model_id, key, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_threat_model_metadata_by_key_with_http_info(threat_model_id, key, **kwargs)  # noqa: E501
            return data

    def delete_threat_model_metadata_by_key_with_http_info(self, threat_model_id, key, **kwargs):  # noqa: E501
        """Delete threat model metadata by key  # noqa: E501

        Deletes a specific metadata entry by key for the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_threat_model_metadata_by_key_with_http_info(threat_model_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str key: Metadata key to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_threat_model_metadata_by_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `delete_threat_model_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'key' is set
        if ('key' not in params or
                params['key'] is None):
            raise ValueError("Missing the required parameter `key` when calling `delete_threat_model_metadata_by_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/metadata/{key}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_threat_model_note(self, threat_model_id, note_id, **kwargs):  # noqa: E501
        """Delete a note  # noqa: E501

        Deletes a specific note from the threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_threat_model_note(threat_model_id, note_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str note_id: Unique identifier of the note (UUID) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_threat_model_note_with_http_info(threat_model_id, note_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_threat_model_note_with_http_info(threat_model_id, note_id, **kwargs)  # noqa: E501
            return data

    def delete_threat_model_note_with_http_info(self, threat_model_id, note_id, **kwargs):  # noqa: E501
        """Delete a note  # noqa: E501

        Deletes a specific note from the threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_threat_model_note_with_http_info(threat_model_id, note_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str note_id: Unique identifier of the note (UUID) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'note_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_threat_model_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `delete_threat_model_note`")  # noqa: E501
        # verify the required parameter 'note_id' is set
        if ('note_id' not in params or
                params['note_id'] is None):
            raise ValueError("Missing the required parameter `note_id` when calling `delete_threat_model_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'note_id' in params:
            path_params['note_id'] = params['note_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/notes/{note_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_threat_model_repository(self, threat_model_id, repository_id, **kwargs):  # noqa: E501
        """Delete a source reference  # noqa: E501

        Deletes a specific source code reference from the threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_threat_model_repository(threat_model_id, repository_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str repository_id: Unique identifier of the source reference (UUID) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_threat_model_repository_with_http_info(threat_model_id, repository_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_threat_model_repository_with_http_info(threat_model_id, repository_id, **kwargs)  # noqa: E501
            return data

    def delete_threat_model_repository_with_http_info(self, threat_model_id, repository_id, **kwargs):  # noqa: E501
        """Delete a source reference  # noqa: E501

        Deletes a specific source code reference from the threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_threat_model_repository_with_http_info(threat_model_id, repository_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str repository_id: Unique identifier of the source reference (UUID) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'repository_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_threat_model_repository" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `delete_threat_model_repository`")  # noqa: E501
        # verify the required parameter 'repository_id' is set
        if ('repository_id' not in params or
                params['repository_id'] is None):
            raise ValueError("Missing the required parameter `repository_id` when calling `delete_threat_model_repository`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'repository_id' in params:
            path_params['repository_id'] = params['repository_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/repositories/{repository_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_threat_model_threat(self, threat_model_id, threat_id, **kwargs):  # noqa: E501
        """Delete a threat  # noqa: E501

        Deletes a specific threat from the threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_threat_model_threat(threat_model_id, threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str threat_id: Unique identifier of the threat (UUID) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_threat_model_threat_with_http_info(threat_model_id, threat_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_threat_model_threat_with_http_info(threat_model_id, threat_id, **kwargs)  # noqa: E501
            return data

    def delete_threat_model_threat_with_http_info(self, threat_model_id, threat_id, **kwargs):  # noqa: E501
        """Delete a threat  # noqa: E501

        Deletes a specific threat from the threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_threat_model_threat_with_http_info(threat_model_id, threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str threat_id: Unique identifier of the threat (UUID) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'threat_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_threat_model_threat" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `delete_threat_model_threat`")  # noqa: E501
        # verify the required parameter 'threat_id' is set
        if ('threat_id' not in params or
                params['threat_id'] is None):
            raise ValueError("Missing the required parameter `threat_id` when calling `delete_threat_model_threat`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'threat_id' in params:
            path_params['threat_id'] = params['threat_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/threats/{threat_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_diagram_metadata(self, threat_model_id, diagram_id, **kwargs):  # noqa: E501
        """Get diagram metadata  # noqa: E501

        Retrieves all metadata entries for the specified diagram  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_diagram_metadata(threat_model_id, diagram_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str diagram_id: Unique identifier of the diagram (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_diagram_metadata_with_http_info(threat_model_id, diagram_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_diagram_metadata_with_http_info(threat_model_id, diagram_id, **kwargs)  # noqa: E501
            return data

    def get_diagram_metadata_with_http_info(self, threat_model_id, diagram_id, **kwargs):  # noqa: E501
        """Get diagram metadata  # noqa: E501

        Retrieves all metadata entries for the specified diagram  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_diagram_metadata_with_http_info(threat_model_id, diagram_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str diagram_id: Unique identifier of the diagram (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'diagram_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_diagram_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `get_diagram_metadata`")  # noqa: E501
        # verify the required parameter 'diagram_id' is set
        if ('diagram_id' not in params or
                params['diagram_id'] is None):
            raise ValueError("Missing the required parameter `diagram_id` when calling `get_diagram_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'diagram_id' in params:
            path_params['diagram_id'] = params['diagram_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/diagrams/{diagram_id}/metadata', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Metadata]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_diagram_metadata_by_key(self, threat_model_id, diagram_id, key, **kwargs):  # noqa: E501
        """Get diagram metadata by key  # noqa: E501

        Retrieves a specific metadata entry for the diagram by key  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_diagram_metadata_by_key(threat_model_id, diagram_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str diagram_id: Unique identifier of the diagram (UUID) (required)
        :param str key: Metadata key to retrieve (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_diagram_metadata_by_key_with_http_info(threat_model_id, diagram_id, key, **kwargs)  # noqa: E501
        else:
            (data) = self.get_diagram_metadata_by_key_with_http_info(threat_model_id, diagram_id, key, **kwargs)  # noqa: E501
            return data

    def get_diagram_metadata_by_key_with_http_info(self, threat_model_id, diagram_id, key, **kwargs):  # noqa: E501
        """Get diagram metadata by key  # noqa: E501

        Retrieves a specific metadata entry for the diagram by key  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_diagram_metadata_by_key_with_http_info(threat_model_id, diagram_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str diagram_id: Unique identifier of the diagram (UUID) (required)
        :param str key: Metadata key to retrieve (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'diagram_id', 'key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_diagram_metadata_by_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `get_diagram_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'diagram_id' is set
        if ('diagram_id' not in params or
                params['diagram_id'] is None):
            raise ValueError("Missing the required parameter `diagram_id` when calling `get_diagram_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'key' is set
        if ('key' not in params or
                params['key'] is None):
            raise ValueError("Missing the required parameter `key` when calling `get_diagram_metadata_by_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'diagram_id' in params:
            path_params['diagram_id'] = params['diagram_id']  # noqa: E501
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/diagrams/{diagram_id}/metadata/{key}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Metadata',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_document_metadata(self, threat_model_id, document_id, **kwargs):  # noqa: E501
        """Get document metadata  # noqa: E501

        Returns all metadata key-value pairs for the specified document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_document_metadata(threat_model_id, document_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str document_id: Unique identifier of the document (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_document_metadata_with_http_info(threat_model_id, document_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_document_metadata_with_http_info(threat_model_id, document_id, **kwargs)  # noqa: E501
            return data

    def get_document_metadata_with_http_info(self, threat_model_id, document_id, **kwargs):  # noqa: E501
        """Get document metadata  # noqa: E501

        Returns all metadata key-value pairs for the specified document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_document_metadata_with_http_info(threat_model_id, document_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str document_id: Unique identifier of the document (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'document_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `get_document_metadata`")  # noqa: E501
        # verify the required parameter 'document_id' is set
        if ('document_id' not in params or
                params['document_id'] is None):
            raise ValueError("Missing the required parameter `document_id` when calling `get_document_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'document_id' in params:
            path_params['document_id'] = params['document_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/documents/{document_id}/metadata', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Metadata]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_document_metadata_by_key(self, threat_model_id, document_id, key, **kwargs):  # noqa: E501
        """Get document metadata by key  # noqa: E501

        Returns a specific metadata entry by key for the specified document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_document_metadata_by_key(threat_model_id, document_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str document_id: Unique identifier of the document (UUID) (required)
        :param str key: Metadata key to retrieve (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_document_metadata_by_key_with_http_info(threat_model_id, document_id, key, **kwargs)  # noqa: E501
        else:
            (data) = self.get_document_metadata_by_key_with_http_info(threat_model_id, document_id, key, **kwargs)  # noqa: E501
            return data

    def get_document_metadata_by_key_with_http_info(self, threat_model_id, document_id, key, **kwargs):  # noqa: E501
        """Get document metadata by key  # noqa: E501

        Returns a specific metadata entry by key for the specified document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_document_metadata_by_key_with_http_info(threat_model_id, document_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str document_id: Unique identifier of the document (UUID) (required)
        :param str key: Metadata key to retrieve (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'document_id', 'key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_metadata_by_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `get_document_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'document_id' is set
        if ('document_id' not in params or
                params['document_id'] is None):
            raise ValueError("Missing the required parameter `document_id` when calling `get_document_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'key' is set
        if ('key' not in params or
                params['key'] is None):
            raise ValueError("Missing the required parameter `key` when calling `get_document_metadata_by_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'document_id' in params:
            path_params['document_id'] = params['document_id']  # noqa: E501
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/documents/{document_id}/metadata/{key}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Metadata',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_note_metadata(self, threat_model_id, note_id, **kwargs):  # noqa: E501
        """Get note metadata  # noqa: E501

        Returns all metadata key-value pairs for the specified note  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_note_metadata(threat_model_id, note_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str note_id: Unique identifier of the note (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_note_metadata_with_http_info(threat_model_id, note_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_note_metadata_with_http_info(threat_model_id, note_id, **kwargs)  # noqa: E501
            return data

    def get_note_metadata_with_http_info(self, threat_model_id, note_id, **kwargs):  # noqa: E501
        """Get note metadata  # noqa: E501

        Returns all metadata key-value pairs for the specified note  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_note_metadata_with_http_info(threat_model_id, note_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str note_id: Unique identifier of the note (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'note_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_note_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `get_note_metadata`")  # noqa: E501
        # verify the required parameter 'note_id' is set
        if ('note_id' not in params or
                params['note_id'] is None):
            raise ValueError("Missing the required parameter `note_id` when calling `get_note_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'note_id' in params:
            path_params['note_id'] = params['note_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/notes/{note_id}/metadata', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Metadata]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_note_metadata_by_key(self, threat_model_id, note_id, key, **kwargs):  # noqa: E501
        """Get note metadata by key  # noqa: E501

        Returns a specific metadata entry by key for the specified note  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_note_metadata_by_key(threat_model_id, note_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str note_id: Unique identifier of the note (UUID) (required)
        :param str key: Metadata key to retrieve (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_note_metadata_by_key_with_http_info(threat_model_id, note_id, key, **kwargs)  # noqa: E501
        else:
            (data) = self.get_note_metadata_by_key_with_http_info(threat_model_id, note_id, key, **kwargs)  # noqa: E501
            return data

    def get_note_metadata_by_key_with_http_info(self, threat_model_id, note_id, key, **kwargs):  # noqa: E501
        """Get note metadata by key  # noqa: E501

        Returns a specific metadata entry by key for the specified note  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_note_metadata_by_key_with_http_info(threat_model_id, note_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str note_id: Unique identifier of the note (UUID) (required)
        :param str key: Metadata key to retrieve (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'note_id', 'key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_note_metadata_by_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `get_note_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'note_id' is set
        if ('note_id' not in params or
                params['note_id'] is None):
            raise ValueError("Missing the required parameter `note_id` when calling `get_note_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'key' is set
        if ('key' not in params or
                params['key'] is None):
            raise ValueError("Missing the required parameter `key` when calling `get_note_metadata_by_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'note_id' in params:
            path_params['note_id'] = params['note_id']  # noqa: E501
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/notes/{note_id}/metadata/{key}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Metadata',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_repository_metadata(self, threat_model_id, repository_id, **kwargs):  # noqa: E501
        """Get source metadata  # noqa: E501

        Returns all metadata key-value pairs for the specified source reference  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repository_metadata(threat_model_id, repository_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str repository_id: Unique identifier of the source reference (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_repository_metadata_with_http_info(threat_model_id, repository_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_repository_metadata_with_http_info(threat_model_id, repository_id, **kwargs)  # noqa: E501
            return data

    def get_repository_metadata_with_http_info(self, threat_model_id, repository_id, **kwargs):  # noqa: E501
        """Get source metadata  # noqa: E501

        Returns all metadata key-value pairs for the specified source reference  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repository_metadata_with_http_info(threat_model_id, repository_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str repository_id: Unique identifier of the source reference (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'repository_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repository_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `get_repository_metadata`")  # noqa: E501
        # verify the required parameter 'repository_id' is set
        if ('repository_id' not in params or
                params['repository_id'] is None):
            raise ValueError("Missing the required parameter `repository_id` when calling `get_repository_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'repository_id' in params:
            path_params['repository_id'] = params['repository_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/repositories/{repository_id}/metadata', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Metadata]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_repository_metadata_by_key(self, threat_model_id, repository_id, key, **kwargs):  # noqa: E501
        """Get source metadata by key  # noqa: E501

        Returns a specific metadata entry by key for the specified source reference  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repository_metadata_by_key(threat_model_id, repository_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str repository_id: Unique identifier of the source reference (UUID) (required)
        :param str key: Metadata key to retrieve (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_repository_metadata_by_key_with_http_info(threat_model_id, repository_id, key, **kwargs)  # noqa: E501
        else:
            (data) = self.get_repository_metadata_by_key_with_http_info(threat_model_id, repository_id, key, **kwargs)  # noqa: E501
            return data

    def get_repository_metadata_by_key_with_http_info(self, threat_model_id, repository_id, key, **kwargs):  # noqa: E501
        """Get source metadata by key  # noqa: E501

        Returns a specific metadata entry by key for the specified source reference  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repository_metadata_by_key_with_http_info(threat_model_id, repository_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str repository_id: Unique identifier of the source reference (UUID) (required)
        :param str key: Metadata key to retrieve (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'repository_id', 'key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repository_metadata_by_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `get_repository_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'repository_id' is set
        if ('repository_id' not in params or
                params['repository_id'] is None):
            raise ValueError("Missing the required parameter `repository_id` when calling `get_repository_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'key' is set
        if ('key' not in params or
                params['key'] is None):
            raise ValueError("Missing the required parameter `key` when calling `get_repository_metadata_by_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'repository_id' in params:
            path_params['repository_id'] = params['repository_id']  # noqa: E501
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/repositories/{repository_id}/metadata/{key}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Metadata',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_threat_metadata(self, threat_model_id, threat_id, **kwargs):  # noqa: E501
        """Get threat metadata  # noqa: E501

        Returns all metadata key-value pairs for the specified threat  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_metadata(threat_model_id, threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str threat_id: Unique identifier of the threat (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_threat_metadata_with_http_info(threat_model_id, threat_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_threat_metadata_with_http_info(threat_model_id, threat_id, **kwargs)  # noqa: E501
            return data

    def get_threat_metadata_with_http_info(self, threat_model_id, threat_id, **kwargs):  # noqa: E501
        """Get threat metadata  # noqa: E501

        Returns all metadata key-value pairs for the specified threat  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_metadata_with_http_info(threat_model_id, threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str threat_id: Unique identifier of the threat (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'threat_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_threat_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `get_threat_metadata`")  # noqa: E501
        # verify the required parameter 'threat_id' is set
        if ('threat_id' not in params or
                params['threat_id'] is None):
            raise ValueError("Missing the required parameter `threat_id` when calling `get_threat_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'threat_id' in params:
            path_params['threat_id'] = params['threat_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/threats/{threat_id}/metadata', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Metadata]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_threat_metadata_by_key(self, threat_model_id, threat_id, key, **kwargs):  # noqa: E501
        """Get threat metadata by key  # noqa: E501

        Returns a specific metadata entry by key for the specified threat  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_metadata_by_key(threat_model_id, threat_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str threat_id: Unique identifier of the threat (UUID) (required)
        :param str key: Metadata key to retrieve (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_threat_metadata_by_key_with_http_info(threat_model_id, threat_id, key, **kwargs)  # noqa: E501
        else:
            (data) = self.get_threat_metadata_by_key_with_http_info(threat_model_id, threat_id, key, **kwargs)  # noqa: E501
            return data

    def get_threat_metadata_by_key_with_http_info(self, threat_model_id, threat_id, key, **kwargs):  # noqa: E501
        """Get threat metadata by key  # noqa: E501

        Returns a specific metadata entry by key for the specified threat  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_metadata_by_key_with_http_info(threat_model_id, threat_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str threat_id: Unique identifier of the threat (UUID) (required)
        :param str key: Metadata key to retrieve (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'threat_id', 'key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_threat_metadata_by_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `get_threat_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'threat_id' is set
        if ('threat_id' not in params or
                params['threat_id'] is None):
            raise ValueError("Missing the required parameter `threat_id` when calling `get_threat_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'key' is set
        if ('key' not in params or
                params['key'] is None):
            raise ValueError("Missing the required parameter `key` when calling `get_threat_metadata_by_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'threat_id' in params:
            path_params['threat_id'] = params['threat_id']  # noqa: E501
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/threats/{threat_id}/metadata/{key}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Metadata',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_threat_model_asset(self, threat_model_id, asset_id, **kwargs):  # noqa: E501
        """Get a specific asset  # noqa: E501

        Returns a single asset by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_model_asset(threat_model_id, asset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str asset_id: Unique identifier of the asset (UUID) (required)
        :return: Asset
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_threat_model_asset_with_http_info(threat_model_id, asset_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_threat_model_asset_with_http_info(threat_model_id, asset_id, **kwargs)  # noqa: E501
            return data

    def get_threat_model_asset_with_http_info(self, threat_model_id, asset_id, **kwargs):  # noqa: E501
        """Get a specific asset  # noqa: E501

        Returns a single asset by its ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_model_asset_with_http_info(threat_model_id, asset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str asset_id: Unique identifier of the asset (UUID) (required)
        :return: Asset
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'asset_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_threat_model_asset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `get_threat_model_asset`")  # noqa: E501
        # verify the required parameter 'asset_id' is set
        if ('asset_id' not in params or
                params['asset_id'] is None):
            raise ValueError("Missing the required parameter `asset_id` when calling `get_threat_model_asset`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'asset_id' in params:
            path_params['asset_id'] = params['asset_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/assets/{asset_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Asset',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_threat_model_asset_metadata(self, threat_model_id, asset_id, **kwargs):  # noqa: E501
        """Get all metadata for an asset  # noqa: E501

        Returns all metadata key-value pairs for the specified asset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_model_asset_metadata(threat_model_id, asset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str asset_id: Unique identifier of the asset (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_threat_model_asset_metadata_with_http_info(threat_model_id, asset_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_threat_model_asset_metadata_with_http_info(threat_model_id, asset_id, **kwargs)  # noqa: E501
            return data

    def get_threat_model_asset_metadata_with_http_info(self, threat_model_id, asset_id, **kwargs):  # noqa: E501
        """Get all metadata for an asset  # noqa: E501

        Returns all metadata key-value pairs for the specified asset  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_model_asset_metadata_with_http_info(threat_model_id, asset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str asset_id: Unique identifier of the asset (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'asset_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_threat_model_asset_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `get_threat_model_asset_metadata`")  # noqa: E501
        # verify the required parameter 'asset_id' is set
        if ('asset_id' not in params or
                params['asset_id'] is None):
            raise ValueError("Missing the required parameter `asset_id` when calling `get_threat_model_asset_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'asset_id' in params:
            path_params['asset_id'] = params['asset_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/assets/{asset_id}/metadata', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Metadata]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_threat_model_asset_metadata_by_key(self, threat_model_id, asset_id, key, **kwargs):  # noqa: E501
        """Get specific metadata for an asset  # noqa: E501

        Returns a single metadata value by its key  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_model_asset_metadata_by_key(threat_model_id, asset_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str asset_id: Unique identifier of the asset (UUID) (required)
        :param str key: Metadata key (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_threat_model_asset_metadata_by_key_with_http_info(threat_model_id, asset_id, key, **kwargs)  # noqa: E501
        else:
            (data) = self.get_threat_model_asset_metadata_by_key_with_http_info(threat_model_id, asset_id, key, **kwargs)  # noqa: E501
            return data

    def get_threat_model_asset_metadata_by_key_with_http_info(self, threat_model_id, asset_id, key, **kwargs):  # noqa: E501
        """Get specific metadata for an asset  # noqa: E501

        Returns a single metadata value by its key  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_model_asset_metadata_by_key_with_http_info(threat_model_id, asset_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str asset_id: Unique identifier of the asset (UUID) (required)
        :param str key: Metadata key (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'asset_id', 'key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_threat_model_asset_metadata_by_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `get_threat_model_asset_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'asset_id' is set
        if ('asset_id' not in params or
                params['asset_id'] is None):
            raise ValueError("Missing the required parameter `asset_id` when calling `get_threat_model_asset_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'key' is set
        if ('key' not in params or
                params['key'] is None):
            raise ValueError("Missing the required parameter `key` when calling `get_threat_model_asset_metadata_by_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'asset_id' in params:
            path_params['asset_id'] = params['asset_id']  # noqa: E501
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/assets/{asset_id}/metadata/{key}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Metadata',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_threat_model_assets(self, threat_model_id, **kwargs):  # noqa: E501
        """List assets in a threat model  # noqa: E501

        Returns a paginated list of assets within the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_model_assets(threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param int limit: Maximum number of assets to return
        :param int offset: Number of assets to skip
        :return: list[Asset]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_threat_model_assets_with_http_info(threat_model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_threat_model_assets_with_http_info(threat_model_id, **kwargs)  # noqa: E501
            return data

    def get_threat_model_assets_with_http_info(self, threat_model_id, **kwargs):  # noqa: E501
        """List assets in a threat model  # noqa: E501

        Returns a paginated list of assets within the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_model_assets_with_http_info(threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param int limit: Maximum number of assets to return
        :param int offset: Number of assets to skip
        :return: list[Asset]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_threat_model_assets" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `get_threat_model_assets`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/assets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Asset]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_threat_model_diagram(self, threat_model_id, diagram_id, **kwargs):  # noqa: E501
        """Get a specific diagram  # noqa: E501

        Retrieves a specific diagram from the threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_model_diagram(threat_model_id, diagram_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str diagram_id: Unique identifier of the diagram (UUID) (required)
        :return: Diagram
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_threat_model_diagram_with_http_info(threat_model_id, diagram_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_threat_model_diagram_with_http_info(threat_model_id, diagram_id, **kwargs)  # noqa: E501
            return data

    def get_threat_model_diagram_with_http_info(self, threat_model_id, diagram_id, **kwargs):  # noqa: E501
        """Get a specific diagram  # noqa: E501

        Retrieves a specific diagram from the threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_model_diagram_with_http_info(threat_model_id, diagram_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str diagram_id: Unique identifier of the diagram (UUID) (required)
        :return: Diagram
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'diagram_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_threat_model_diagram" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `get_threat_model_diagram`")  # noqa: E501
        # verify the required parameter 'diagram_id' is set
        if ('diagram_id' not in params or
                params['diagram_id'] is None):
            raise ValueError("Missing the required parameter `diagram_id` when calling `get_threat_model_diagram`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'diagram_id' in params:
            path_params['diagram_id'] = params['diagram_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/diagrams/{diagram_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Diagram',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_threat_model_diagrams(self, threat_model_id, **kwargs):  # noqa: E501
        """List threat model diagrams  # noqa: E501

        Returns all diagrams associated with a specific threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_model_diagrams(threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param int limit: Maximum number of items to return
        :param int offset: Number of items to skip
        :return: list[DiagramListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_threat_model_diagrams_with_http_info(threat_model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_threat_model_diagrams_with_http_info(threat_model_id, **kwargs)  # noqa: E501
            return data

    def get_threat_model_diagrams_with_http_info(self, threat_model_id, **kwargs):  # noqa: E501
        """List threat model diagrams  # noqa: E501

        Returns all diagrams associated with a specific threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_model_diagrams_with_http_info(threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param int limit: Maximum number of items to return
        :param int offset: Number of items to skip
        :return: list[DiagramListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_threat_model_diagrams" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `get_threat_model_diagrams`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/diagrams', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DiagramListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_threat_model_document(self, threat_model_id, document_id, **kwargs):  # noqa: E501
        """Get a specific document  # noqa: E501

        Returns details of a specific document within the threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_model_document(threat_model_id, document_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str document_id: Unique identifier of the document (UUID) (required)
        :return: Document
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_threat_model_document_with_http_info(threat_model_id, document_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_threat_model_document_with_http_info(threat_model_id, document_id, **kwargs)  # noqa: E501
            return data

    def get_threat_model_document_with_http_info(self, threat_model_id, document_id, **kwargs):  # noqa: E501
        """Get a specific document  # noqa: E501

        Returns details of a specific document within the threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_model_document_with_http_info(threat_model_id, document_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str document_id: Unique identifier of the document (UUID) (required)
        :return: Document
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'document_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_threat_model_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `get_threat_model_document`")  # noqa: E501
        # verify the required parameter 'document_id' is set
        if ('document_id' not in params or
                params['document_id'] is None):
            raise ValueError("Missing the required parameter `document_id` when calling `get_threat_model_document`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'document_id' in params:
            path_params['document_id'] = params['document_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/documents/{document_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Document',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_threat_model_documents(self, threat_model_id, **kwargs):  # noqa: E501
        """List documents in a threat model  # noqa: E501

        Returns a paginated list of documents within the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_model_documents(threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param int limit: Maximum number of documents to return
        :param int offset: Number of documents to skip
        :return: list[Document]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_threat_model_documents_with_http_info(threat_model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_threat_model_documents_with_http_info(threat_model_id, **kwargs)  # noqa: E501
            return data

    def get_threat_model_documents_with_http_info(self, threat_model_id, **kwargs):  # noqa: E501
        """List documents in a threat model  # noqa: E501

        Returns a paginated list of documents within the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_model_documents_with_http_info(threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param int limit: Maximum number of documents to return
        :param int offset: Number of documents to skip
        :return: list[Document]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_threat_model_documents" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `get_threat_model_documents`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/documents', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Document]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_threat_model_metadata(self, threat_model_id, **kwargs):  # noqa: E501
        """Get threat model metadata  # noqa: E501

        Returns all metadata key-value pairs for the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_model_metadata(threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_threat_model_metadata_with_http_info(threat_model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_threat_model_metadata_with_http_info(threat_model_id, **kwargs)  # noqa: E501
            return data

    def get_threat_model_metadata_with_http_info(self, threat_model_id, **kwargs):  # noqa: E501
        """Get threat model metadata  # noqa: E501

        Returns all metadata key-value pairs for the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_model_metadata_with_http_info(threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :return: list[Metadata]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_threat_model_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `get_threat_model_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/metadata', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Metadata]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_threat_model_metadata_by_key(self, threat_model_id, key, **kwargs):  # noqa: E501
        """Get threat model metadata by key  # noqa: E501

        Returns a specific metadata entry by key for the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_model_metadata_by_key(threat_model_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str key: Metadata key to retrieve (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_threat_model_metadata_by_key_with_http_info(threat_model_id, key, **kwargs)  # noqa: E501
        else:
            (data) = self.get_threat_model_metadata_by_key_with_http_info(threat_model_id, key, **kwargs)  # noqa: E501
            return data

    def get_threat_model_metadata_by_key_with_http_info(self, threat_model_id, key, **kwargs):  # noqa: E501
        """Get threat model metadata by key  # noqa: E501

        Returns a specific metadata entry by key for the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_model_metadata_by_key_with_http_info(threat_model_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str key: Metadata key to retrieve (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_threat_model_metadata_by_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `get_threat_model_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'key' is set
        if ('key' not in params or
                params['key'] is None):
            raise ValueError("Missing the required parameter `key` when calling `get_threat_model_metadata_by_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/metadata/{key}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Metadata',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_threat_model_note(self, threat_model_id, note_id, **kwargs):  # noqa: E501
        """Get a specific note  # noqa: E501

        Returns details of a specific note within the threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_model_note(threat_model_id, note_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str note_id: Unique identifier of the note (UUID) (required)
        :return: Note
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_threat_model_note_with_http_info(threat_model_id, note_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_threat_model_note_with_http_info(threat_model_id, note_id, **kwargs)  # noqa: E501
            return data

    def get_threat_model_note_with_http_info(self, threat_model_id, note_id, **kwargs):  # noqa: E501
        """Get a specific note  # noqa: E501

        Returns details of a specific note within the threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_model_note_with_http_info(threat_model_id, note_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str note_id: Unique identifier of the note (UUID) (required)
        :return: Note
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'note_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_threat_model_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `get_threat_model_note`")  # noqa: E501
        # verify the required parameter 'note_id' is set
        if ('note_id' not in params or
                params['note_id'] is None):
            raise ValueError("Missing the required parameter `note_id` when calling `get_threat_model_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'note_id' in params:
            path_params['note_id'] = params['note_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/notes/{note_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Note',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_threat_model_notes(self, threat_model_id, **kwargs):  # noqa: E501
        """List notes in a threat model  # noqa: E501

        Returns a paginated list of notes within the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_model_notes(threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param int limit: Maximum number of notes to return
        :param int offset: Number of notes to skip
        :return: list[NoteListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_threat_model_notes_with_http_info(threat_model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_threat_model_notes_with_http_info(threat_model_id, **kwargs)  # noqa: E501
            return data

    def get_threat_model_notes_with_http_info(self, threat_model_id, **kwargs):  # noqa: E501
        """List notes in a threat model  # noqa: E501

        Returns a paginated list of notes within the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_model_notes_with_http_info(threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param int limit: Maximum number of notes to return
        :param int offset: Number of notes to skip
        :return: list[NoteListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_threat_model_notes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `get_threat_model_notes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/notes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[NoteListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_threat_model_repositories(self, threat_model_id, **kwargs):  # noqa: E501
        """List sources in a threat model  # noqa: E501

        Returns a paginated list of source code references within the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_model_repositories(threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param int limit: Maximum number of sources to return
        :param int offset: Number of sources to skip
        :return: list[Repository]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_threat_model_repositories_with_http_info(threat_model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_threat_model_repositories_with_http_info(threat_model_id, **kwargs)  # noqa: E501
            return data

    def get_threat_model_repositories_with_http_info(self, threat_model_id, **kwargs):  # noqa: E501
        """List sources in a threat model  # noqa: E501

        Returns a paginated list of source code references within the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_model_repositories_with_http_info(threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param int limit: Maximum number of sources to return
        :param int offset: Number of sources to skip
        :return: list[Repository]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_threat_model_repositories" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `get_threat_model_repositories`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/repositories', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Repository]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_threat_model_repository(self, threat_model_id, repository_id, **kwargs):  # noqa: E501
        """Get a specific source reference  # noqa: E501

        Returns details of a specific source code reference within the threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_model_repository(threat_model_id, repository_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str repository_id: Unique identifier of the source reference (UUID) (required)
        :return: Repository
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_threat_model_repository_with_http_info(threat_model_id, repository_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_threat_model_repository_with_http_info(threat_model_id, repository_id, **kwargs)  # noqa: E501
            return data

    def get_threat_model_repository_with_http_info(self, threat_model_id, repository_id, **kwargs):  # noqa: E501
        """Get a specific source reference  # noqa: E501

        Returns details of a specific source code reference within the threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_model_repository_with_http_info(threat_model_id, repository_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str repository_id: Unique identifier of the source reference (UUID) (required)
        :return: Repository
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'repository_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_threat_model_repository" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `get_threat_model_repository`")  # noqa: E501
        # verify the required parameter 'repository_id' is set
        if ('repository_id' not in params or
                params['repository_id'] is None):
            raise ValueError("Missing the required parameter `repository_id` when calling `get_threat_model_repository`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'repository_id' in params:
            path_params['repository_id'] = params['repository_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/repositories/{repository_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Repository',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_threat_model_threat(self, threat_model_id, threat_id, **kwargs):  # noqa: E501
        """Get a specific threat  # noqa: E501

        Returns details of a specific threat within the threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_model_threat(threat_model_id, threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str threat_id: Unique identifier of the threat (UUID) (required)
        :return: Threat
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_threat_model_threat_with_http_info(threat_model_id, threat_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_threat_model_threat_with_http_info(threat_model_id, threat_id, **kwargs)  # noqa: E501
            return data

    def get_threat_model_threat_with_http_info(self, threat_model_id, threat_id, **kwargs):  # noqa: E501
        """Get a specific threat  # noqa: E501

        Returns details of a specific threat within the threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_model_threat_with_http_info(threat_model_id, threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str threat_id: Unique identifier of the threat (UUID) (required)
        :return: Threat
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'threat_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_threat_model_threat" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `get_threat_model_threat`")  # noqa: E501
        # verify the required parameter 'threat_id' is set
        if ('threat_id' not in params or
                params['threat_id'] is None):
            raise ValueError("Missing the required parameter `threat_id` when calling `get_threat_model_threat`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'threat_id' in params:
            path_params['threat_id'] = params['threat_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/threats/{threat_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Threat',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_threat_model_threats(self, threat_model_id, **kwargs):  # noqa: E501
        """List threats in a threat model  # noqa: E501

        Returns a paginated list of threats within the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_model_threats(threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param int limit: Maximum number of threats to return
        :param int offset: Number of threats to skip
        :param str sort: Sort order (e.g., created_at:desc, name:asc, severity:desc, score:desc)
        :param str name: Filter by threat name (partial match)
        :param str description: Filter by threat description (partial match)
        :param str threat_type: Filter by threat type (exact match)
        :param str severity: Filter by severity level (exact match)
        :param str priority: Filter by priority (exact match)
        :param str status: Filter by status (exact match)
        :param str diagram_id: Filter by diagram ID (exact match)
        :param str cell_id: Filter by cell ID (exact match)
        :param float score_gt: Filter threats with score greater than this value
        :param float score_lt: Filter threats with score less than this value
        :param float score_eq: Filter threats with score equal to this value
        :param float score_ge: Filter threats with score greater than or equal to this value
        :param float score_le: Filter threats with score less than or equal to this value
        :param datetime created_after: Filter threats created after this date (RFC3339 format)
        :param datetime created_before: Filter threats created before this date (RFC3339 format)
        :param datetime modified_after: Filter threats modified after this date (RFC3339 format)
        :param datetime modified_before: Filter threats modified before this date (RFC3339 format)
        :return: list[Threat]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_threat_model_threats_with_http_info(threat_model_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_threat_model_threats_with_http_info(threat_model_id, **kwargs)  # noqa: E501
            return data

    def get_threat_model_threats_with_http_info(self, threat_model_id, **kwargs):  # noqa: E501
        """List threats in a threat model  # noqa: E501

        Returns a paginated list of threats within the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_threat_model_threats_with_http_info(threat_model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param int limit: Maximum number of threats to return
        :param int offset: Number of threats to skip
        :param str sort: Sort order (e.g., created_at:desc, name:asc, severity:desc, score:desc)
        :param str name: Filter by threat name (partial match)
        :param str description: Filter by threat description (partial match)
        :param str threat_type: Filter by threat type (exact match)
        :param str severity: Filter by severity level (exact match)
        :param str priority: Filter by priority (exact match)
        :param str status: Filter by status (exact match)
        :param str diagram_id: Filter by diagram ID (exact match)
        :param str cell_id: Filter by cell ID (exact match)
        :param float score_gt: Filter threats with score greater than this value
        :param float score_lt: Filter threats with score less than this value
        :param float score_eq: Filter threats with score equal to this value
        :param float score_ge: Filter threats with score greater than or equal to this value
        :param float score_le: Filter threats with score less than or equal to this value
        :param datetime created_after: Filter threats created after this date (RFC3339 format)
        :param datetime created_before: Filter threats created before this date (RFC3339 format)
        :param datetime modified_after: Filter threats modified after this date (RFC3339 format)
        :param datetime modified_before: Filter threats modified before this date (RFC3339 format)
        :return: list[Threat]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['threat_model_id', 'limit', 'offset', 'sort', 'name', 'description', 'threat_type', 'severity', 'priority', 'status', 'diagram_id', 'cell_id', 'score_gt', 'score_lt', 'score_eq', 'score_ge', 'score_le', 'created_after', 'created_before', 'modified_after', 'modified_before']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_threat_model_threats" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `get_threat_model_threats`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'description' in params:
            query_params.append(('description', params['description']))  # noqa: E501
        if 'threat_type' in params:
            query_params.append(('threat_type', params['threat_type']))  # noqa: E501
        if 'severity' in params:
            query_params.append(('severity', params['severity']))  # noqa: E501
        if 'priority' in params:
            query_params.append(('priority', params['priority']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'diagram_id' in params:
            query_params.append(('diagram_id', params['diagram_id']))  # noqa: E501
        if 'cell_id' in params:
            query_params.append(('cell_id', params['cell_id']))  # noqa: E501
        if 'score_gt' in params:
            query_params.append(('score_gt', params['score_gt']))  # noqa: E501
        if 'score_lt' in params:
            query_params.append(('score_lt', params['score_lt']))  # noqa: E501
        if 'score_eq' in params:
            query_params.append(('score_eq', params['score_eq']))  # noqa: E501
        if 'score_ge' in params:
            query_params.append(('score_ge', params['score_ge']))  # noqa: E501
        if 'score_le' in params:
            query_params.append(('score_le', params['score_le']))  # noqa: E501
        if 'created_after' in params:
            query_params.append(('created_after', params['created_after']))  # noqa: E501
        if 'created_before' in params:
            query_params.append(('created_before', params['created_before']))  # noqa: E501
        if 'modified_after' in params:
            query_params.append(('modified_after', params['modified_after']))  # noqa: E501
        if 'modified_before' in params:
            query_params.append(('modified_before', params['modified_before']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/threats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Threat]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_threat_model_diagram(self, body, threat_model_id, diagram_id, **kwargs):  # noqa: E501
        """Partially update a diagram  # noqa: E501

        Apply JSON Patch operations to update specific parts of a diagram  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_threat_model_diagram(body, threat_model_id, diagram_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[ThreatsThreatIdBody] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str diagram_id: Unique identifier of the diagram (UUID) (required)
        :return: Diagram
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_threat_model_diagram_with_http_info(body, threat_model_id, diagram_id, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_threat_model_diagram_with_http_info(body, threat_model_id, diagram_id, **kwargs)  # noqa: E501
            return data

    def patch_threat_model_diagram_with_http_info(self, body, threat_model_id, diagram_id, **kwargs):  # noqa: E501
        """Partially update a diagram  # noqa: E501

        Apply JSON Patch operations to update specific parts of a diagram  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_threat_model_diagram_with_http_info(body, threat_model_id, diagram_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[ThreatsThreatIdBody] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str diagram_id: Unique identifier of the diagram (UUID) (required)
        :return: Diagram
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'diagram_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_threat_model_diagram" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_threat_model_diagram`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `patch_threat_model_diagram`")  # noqa: E501
        # verify the required parameter 'diagram_id' is set
        if ('diagram_id' not in params or
                params['diagram_id'] is None):
            raise ValueError("Missing the required parameter `diagram_id` when calling `patch_threat_model_diagram`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'diagram_id' in params:
            path_params['diagram_id'] = params['diagram_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/diagrams/{diagram_id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Diagram',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_threat_model_threat(self, body, threat_model_id, threat_id, **kwargs):  # noqa: E501
        """Partially update a threat  # noqa: E501

        Applies JSON patch operations to a specific threat within the threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_threat_model_threat(body, threat_model_id, threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[ThreatsThreatIdBody] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str threat_id: Unique identifier of the threat (UUID) (required)
        :return: Threat
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.patch_threat_model_threat_with_http_info(body, threat_model_id, threat_id, **kwargs)  # noqa: E501
        else:
            (data) = self.patch_threat_model_threat_with_http_info(body, threat_model_id, threat_id, **kwargs)  # noqa: E501
            return data

    def patch_threat_model_threat_with_http_info(self, body, threat_model_id, threat_id, **kwargs):  # noqa: E501
        """Partially update a threat  # noqa: E501

        Applies JSON patch operations to a specific threat within the threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_threat_model_threat_with_http_info(body, threat_model_id, threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[ThreatsThreatIdBody] body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str threat_id: Unique identifier of the threat (UUID) (required)
        :return: Threat
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'threat_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_threat_model_threat" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `patch_threat_model_threat`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `patch_threat_model_threat`")  # noqa: E501
        # verify the required parameter 'threat_id' is set
        if ('threat_id' not in params or
                params['threat_id'] is None):
            raise ValueError("Missing the required parameter `threat_id` when calling `patch_threat_model_threat`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'threat_id' in params:
            path_params['threat_id'] = params['threat_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json-patch+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/threats/{threat_id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Threat',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_diagram_metadata_by_key(self, body, threat_model_id, diagram_id, key, **kwargs):  # noqa: E501
        """Update diagram metadata by key  # noqa: E501

        Updates or creates a metadata entry for the diagram with the specified key  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_diagram_metadata_by_key(body, threat_model_id, diagram_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MetadataKeyBody4 body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str diagram_id: Unique identifier of the diagram (UUID) (required)
        :param str key: Metadata key to update (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_diagram_metadata_by_key_with_http_info(body, threat_model_id, diagram_id, key, **kwargs)  # noqa: E501
        else:
            (data) = self.update_diagram_metadata_by_key_with_http_info(body, threat_model_id, diagram_id, key, **kwargs)  # noqa: E501
            return data

    def update_diagram_metadata_by_key_with_http_info(self, body, threat_model_id, diagram_id, key, **kwargs):  # noqa: E501
        """Update diagram metadata by key  # noqa: E501

        Updates or creates a metadata entry for the diagram with the specified key  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_diagram_metadata_by_key_with_http_info(body, threat_model_id, diagram_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MetadataKeyBody4 body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str diagram_id: Unique identifier of the diagram (UUID) (required)
        :param str key: Metadata key to update (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'diagram_id', 'key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_diagram_metadata_by_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_diagram_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `update_diagram_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'diagram_id' is set
        if ('diagram_id' not in params or
                params['diagram_id'] is None):
            raise ValueError("Missing the required parameter `diagram_id` when calling `update_diagram_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'key' is set
        if ('key' not in params or
                params['key'] is None):
            raise ValueError("Missing the required parameter `key` when calling `update_diagram_metadata_by_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'diagram_id' in params:
            path_params['diagram_id'] = params['diagram_id']  # noqa: E501
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/diagrams/{diagram_id}/metadata/{key}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Metadata',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_document_metadata_by_key(self, body, threat_model_id, document_id, key, **kwargs):  # noqa: E501
        """Update document metadata by key  # noqa: E501

        Updates a specific metadata entry by key for the specified document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_document_metadata_by_key(body, threat_model_id, document_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MetadataKeyBody1 body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str document_id: Unique identifier of the document (UUID) (required)
        :param str key: Metadata key to update (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_document_metadata_by_key_with_http_info(body, threat_model_id, document_id, key, **kwargs)  # noqa: E501
        else:
            (data) = self.update_document_metadata_by_key_with_http_info(body, threat_model_id, document_id, key, **kwargs)  # noqa: E501
            return data

    def update_document_metadata_by_key_with_http_info(self, body, threat_model_id, document_id, key, **kwargs):  # noqa: E501
        """Update document metadata by key  # noqa: E501

        Updates a specific metadata entry by key for the specified document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_document_metadata_by_key_with_http_info(body, threat_model_id, document_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MetadataKeyBody1 body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str document_id: Unique identifier of the document (UUID) (required)
        :param str key: Metadata key to update (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'document_id', 'key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_document_metadata_by_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_document_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `update_document_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'document_id' is set
        if ('document_id' not in params or
                params['document_id'] is None):
            raise ValueError("Missing the required parameter `document_id` when calling `update_document_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'key' is set
        if ('key' not in params or
                params['key'] is None):
            raise ValueError("Missing the required parameter `key` when calling `update_document_metadata_by_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'document_id' in params:
            path_params['document_id'] = params['document_id']  # noqa: E501
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/documents/{document_id}/metadata/{key}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Metadata',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_note_metadata_by_key(self, body, threat_model_id, note_id, key, **kwargs):  # noqa: E501
        """Update note metadata by key  # noqa: E501

        Updates a specific metadata entry by key for the specified note  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_note_metadata_by_key(body, threat_model_id, note_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MetadataKeyBody5 body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str note_id: Unique identifier of the note (UUID) (required)
        :param str key: Metadata key to update (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_note_metadata_by_key_with_http_info(body, threat_model_id, note_id, key, **kwargs)  # noqa: E501
        else:
            (data) = self.update_note_metadata_by_key_with_http_info(body, threat_model_id, note_id, key, **kwargs)  # noqa: E501
            return data

    def update_note_metadata_by_key_with_http_info(self, body, threat_model_id, note_id, key, **kwargs):  # noqa: E501
        """Update note metadata by key  # noqa: E501

        Updates a specific metadata entry by key for the specified note  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_note_metadata_by_key_with_http_info(body, threat_model_id, note_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MetadataKeyBody5 body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str note_id: Unique identifier of the note (UUID) (required)
        :param str key: Metadata key to update (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'note_id', 'key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_note_metadata_by_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_note_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `update_note_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'note_id' is set
        if ('note_id' not in params or
                params['note_id'] is None):
            raise ValueError("Missing the required parameter `note_id` when calling `update_note_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'key' is set
        if ('key' not in params or
                params['key'] is None):
            raise ValueError("Missing the required parameter `key` when calling `update_note_metadata_by_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'note_id' in params:
            path_params['note_id'] = params['note_id']  # noqa: E501
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/notes/{note_id}/metadata/{key}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Metadata',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_repository_metadata_by_key(self, body, threat_model_id, repository_id, key, **kwargs):  # noqa: E501
        """Update source metadata by key  # noqa: E501

        Updates a specific metadata entry by key for the specified source reference  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_repository_metadata_by_key(body, threat_model_id, repository_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MetadataKeyBody2 body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str repository_id: Unique identifier of the source reference (UUID) (required)
        :param str key: Metadata key to update (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_repository_metadata_by_key_with_http_info(body, threat_model_id, repository_id, key, **kwargs)  # noqa: E501
        else:
            (data) = self.update_repository_metadata_by_key_with_http_info(body, threat_model_id, repository_id, key, **kwargs)  # noqa: E501
            return data

    def update_repository_metadata_by_key_with_http_info(self, body, threat_model_id, repository_id, key, **kwargs):  # noqa: E501
        """Update source metadata by key  # noqa: E501

        Updates a specific metadata entry by key for the specified source reference  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_repository_metadata_by_key_with_http_info(body, threat_model_id, repository_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MetadataKeyBody2 body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str repository_id: Unique identifier of the source reference (UUID) (required)
        :param str key: Metadata key to update (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'repository_id', 'key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_repository_metadata_by_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_repository_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `update_repository_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'repository_id' is set
        if ('repository_id' not in params or
                params['repository_id'] is None):
            raise ValueError("Missing the required parameter `repository_id` when calling `update_repository_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'key' is set
        if ('key' not in params or
                params['key'] is None):
            raise ValueError("Missing the required parameter `key` when calling `update_repository_metadata_by_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'repository_id' in params:
            path_params['repository_id'] = params['repository_id']  # noqa: E501
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/repositories/{repository_id}/metadata/{key}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Metadata',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_threat_metadata_by_key(self, body, threat_model_id, threat_id, key, **kwargs):  # noqa: E501
        """Update threat metadata by key  # noqa: E501

        Updates a specific metadata entry by key for the specified threat  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_threat_metadata_by_key(body, threat_model_id, threat_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MetadataKeyBody body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str threat_id: Unique identifier of the threat (UUID) (required)
        :param str key: Metadata key to update (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_threat_metadata_by_key_with_http_info(body, threat_model_id, threat_id, key, **kwargs)  # noqa: E501
        else:
            (data) = self.update_threat_metadata_by_key_with_http_info(body, threat_model_id, threat_id, key, **kwargs)  # noqa: E501
            return data

    def update_threat_metadata_by_key_with_http_info(self, body, threat_model_id, threat_id, key, **kwargs):  # noqa: E501
        """Update threat metadata by key  # noqa: E501

        Updates a specific metadata entry by key for the specified threat  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_threat_metadata_by_key_with_http_info(body, threat_model_id, threat_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MetadataKeyBody body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str threat_id: Unique identifier of the threat (UUID) (required)
        :param str key: Metadata key to update (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'threat_id', 'key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_threat_metadata_by_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_threat_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `update_threat_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'threat_id' is set
        if ('threat_id' not in params or
                params['threat_id'] is None):
            raise ValueError("Missing the required parameter `threat_id` when calling `update_threat_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'key' is set
        if ('key' not in params or
                params['key'] is None):
            raise ValueError("Missing the required parameter `key` when calling `update_threat_metadata_by_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'threat_id' in params:
            path_params['threat_id'] = params['threat_id']  # noqa: E501
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/threats/{threat_id}/metadata/{key}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Metadata',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_threat_model_asset(self, body, threat_model_id, asset_id, **kwargs):  # noqa: E501
        """Update an asset  # noqa: E501

        Updates an existing asset within the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_threat_model_asset(body, threat_model_id, asset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AssetInput body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str asset_id: Unique identifier of the asset (UUID) (required)
        :return: Asset
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_threat_model_asset_with_http_info(body, threat_model_id, asset_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_threat_model_asset_with_http_info(body, threat_model_id, asset_id, **kwargs)  # noqa: E501
            return data

    def update_threat_model_asset_with_http_info(self, body, threat_model_id, asset_id, **kwargs):  # noqa: E501
        """Update an asset  # noqa: E501

        Updates an existing asset within the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_threat_model_asset_with_http_info(body, threat_model_id, asset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AssetInput body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str asset_id: Unique identifier of the asset (UUID) (required)
        :return: Asset
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'asset_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_threat_model_asset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_threat_model_asset`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `update_threat_model_asset`")  # noqa: E501
        # verify the required parameter 'asset_id' is set
        if ('asset_id' not in params or
                params['asset_id'] is None):
            raise ValueError("Missing the required parameter `asset_id` when calling `update_threat_model_asset`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'asset_id' in params:
            path_params['asset_id'] = params['asset_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/assets/{asset_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Asset',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_threat_model_asset_metadata(self, body, threat_model_id, asset_id, key, **kwargs):  # noqa: E501
        """Update asset metadata  # noqa: E501

        Updates an existing metadata value by its key  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_threat_model_asset_metadata(body, threat_model_id, asset_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Metadata body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str asset_id: Unique identifier of the asset (UUID) (required)
        :param str key: Metadata key (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_threat_model_asset_metadata_with_http_info(body, threat_model_id, asset_id, key, **kwargs)  # noqa: E501
        else:
            (data) = self.update_threat_model_asset_metadata_with_http_info(body, threat_model_id, asset_id, key, **kwargs)  # noqa: E501
            return data

    def update_threat_model_asset_metadata_with_http_info(self, body, threat_model_id, asset_id, key, **kwargs):  # noqa: E501
        """Update asset metadata  # noqa: E501

        Updates an existing metadata value by its key  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_threat_model_asset_metadata_with_http_info(body, threat_model_id, asset_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Metadata body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str asset_id: Unique identifier of the asset (UUID) (required)
        :param str key: Metadata key (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'asset_id', 'key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_threat_model_asset_metadata" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_threat_model_asset_metadata`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `update_threat_model_asset_metadata`")  # noqa: E501
        # verify the required parameter 'asset_id' is set
        if ('asset_id' not in params or
                params['asset_id'] is None):
            raise ValueError("Missing the required parameter `asset_id` when calling `update_threat_model_asset_metadata`")  # noqa: E501
        # verify the required parameter 'key' is set
        if ('key' not in params or
                params['key'] is None):
            raise ValueError("Missing the required parameter `key` when calling `update_threat_model_asset_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'asset_id' in params:
            path_params['asset_id'] = params['asset_id']  # noqa: E501
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/assets/{asset_id}/metadata/{key}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Metadata',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_threat_model_diagram(self, body, threat_model_id, diagram_id, **kwargs):  # noqa: E501
        """Update a diagram  # noqa: E501

        Completely replaces a diagram with new data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_threat_model_diagram(body, threat_model_id, diagram_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Diagram body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str diagram_id: Unique identifier of the diagram (UUID) (required)
        :return: Diagram
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_threat_model_diagram_with_http_info(body, threat_model_id, diagram_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_threat_model_diagram_with_http_info(body, threat_model_id, diagram_id, **kwargs)  # noqa: E501
            return data

    def update_threat_model_diagram_with_http_info(self, body, threat_model_id, diagram_id, **kwargs):  # noqa: E501
        """Update a diagram  # noqa: E501

        Completely replaces a diagram with new data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_threat_model_diagram_with_http_info(body, threat_model_id, diagram_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Diagram body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str diagram_id: Unique identifier of the diagram (UUID) (required)
        :return: Diagram
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'diagram_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_threat_model_diagram" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_threat_model_diagram`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `update_threat_model_diagram`")  # noqa: E501
        # verify the required parameter 'diagram_id' is set
        if ('diagram_id' not in params or
                params['diagram_id'] is None):
            raise ValueError("Missing the required parameter `diagram_id` when calling `update_threat_model_diagram`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'diagram_id' in params:
            path_params['diagram_id'] = params['diagram_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/diagrams/{diagram_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Diagram',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_threat_model_document(self, body, threat_model_id, document_id, **kwargs):  # noqa: E501
        """Update a document  # noqa: E501

        Updates a specific document within the threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_threat_model_document(body, threat_model_id, document_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DocumentInput body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str document_id: Unique identifier of the document (UUID) (required)
        :return: Document
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_threat_model_document_with_http_info(body, threat_model_id, document_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_threat_model_document_with_http_info(body, threat_model_id, document_id, **kwargs)  # noqa: E501
            return data

    def update_threat_model_document_with_http_info(self, body, threat_model_id, document_id, **kwargs):  # noqa: E501
        """Update a document  # noqa: E501

        Updates a specific document within the threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_threat_model_document_with_http_info(body, threat_model_id, document_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DocumentInput body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str document_id: Unique identifier of the document (UUID) (required)
        :return: Document
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'document_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_threat_model_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_threat_model_document`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `update_threat_model_document`")  # noqa: E501
        # verify the required parameter 'document_id' is set
        if ('document_id' not in params or
                params['document_id'] is None):
            raise ValueError("Missing the required parameter `document_id` when calling `update_threat_model_document`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'document_id' in params:
            path_params['document_id'] = params['document_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/documents/{document_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Document',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_threat_model_metadata_by_key(self, body, threat_model_id, key, **kwargs):  # noqa: E501
        """Update threat model metadata by key  # noqa: E501

        Updates a specific metadata entry by key for the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_threat_model_metadata_by_key(body, threat_model_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MetadataKeyBody3 body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str key: Metadata key to update (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_threat_model_metadata_by_key_with_http_info(body, threat_model_id, key, **kwargs)  # noqa: E501
        else:
            (data) = self.update_threat_model_metadata_by_key_with_http_info(body, threat_model_id, key, **kwargs)  # noqa: E501
            return data

    def update_threat_model_metadata_by_key_with_http_info(self, body, threat_model_id, key, **kwargs):  # noqa: E501
        """Update threat model metadata by key  # noqa: E501

        Updates a specific metadata entry by key for the specified threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_threat_model_metadata_by_key_with_http_info(body, threat_model_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MetadataKeyBody3 body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str key: Metadata key to update (required)
        :return: Metadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_threat_model_metadata_by_key" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_threat_model_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `update_threat_model_metadata_by_key`")  # noqa: E501
        # verify the required parameter 'key' is set
        if ('key' not in params or
                params['key'] is None):
            raise ValueError("Missing the required parameter `key` when calling `update_threat_model_metadata_by_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'key' in params:
            path_params['key'] = params['key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/metadata/{key}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Metadata',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_threat_model_note(self, body, threat_model_id, note_id, **kwargs):  # noqa: E501
        """Update a note  # noqa: E501

        Updates a specific note within the threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_threat_model_note(body, threat_model_id, note_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NoteInput body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str note_id: Unique identifier of the note (UUID) (required)
        :return: Note
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_threat_model_note_with_http_info(body, threat_model_id, note_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_threat_model_note_with_http_info(body, threat_model_id, note_id, **kwargs)  # noqa: E501
            return data

    def update_threat_model_note_with_http_info(self, body, threat_model_id, note_id, **kwargs):  # noqa: E501
        """Update a note  # noqa: E501

        Updates a specific note within the threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_threat_model_note_with_http_info(body, threat_model_id, note_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NoteInput body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str note_id: Unique identifier of the note (UUID) (required)
        :return: Note
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'note_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_threat_model_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_threat_model_note`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `update_threat_model_note`")  # noqa: E501
        # verify the required parameter 'note_id' is set
        if ('note_id' not in params or
                params['note_id'] is None):
            raise ValueError("Missing the required parameter `note_id` when calling `update_threat_model_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'note_id' in params:
            path_params['note_id'] = params['note_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/notes/{note_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Note',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_threat_model_repository(self, body, threat_model_id, repository_id, **kwargs):  # noqa: E501
        """Update a source reference  # noqa: E501

        Updates a specific source code reference within the threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_threat_model_repository(body, threat_model_id, repository_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RepositoryInput body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str repository_id: Unique identifier of the source reference (UUID) (required)
        :return: Repository
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_threat_model_repository_with_http_info(body, threat_model_id, repository_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_threat_model_repository_with_http_info(body, threat_model_id, repository_id, **kwargs)  # noqa: E501
            return data

    def update_threat_model_repository_with_http_info(self, body, threat_model_id, repository_id, **kwargs):  # noqa: E501
        """Update a source reference  # noqa: E501

        Updates a specific source code reference within the threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_threat_model_repository_with_http_info(body, threat_model_id, repository_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RepositoryInput body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str repository_id: Unique identifier of the source reference (UUID) (required)
        :return: Repository
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'repository_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_threat_model_repository" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_threat_model_repository`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `update_threat_model_repository`")  # noqa: E501
        # verify the required parameter 'repository_id' is set
        if ('repository_id' not in params or
                params['repository_id'] is None):
            raise ValueError("Missing the required parameter `repository_id` when calling `update_threat_model_repository`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'repository_id' in params:
            path_params['repository_id'] = params['repository_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/repositories/{repository_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Repository',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_threat_model_threat(self, body, threat_model_id, threat_id, **kwargs):  # noqa: E501
        """Update a threat  # noqa: E501

        Updates a specific threat within the threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_threat_model_threat(body, threat_model_id, threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ThreatInput body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str threat_id: Unique identifier of the threat (UUID) (required)
        :return: Threat
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_threat_model_threat_with_http_info(body, threat_model_id, threat_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_threat_model_threat_with_http_info(body, threat_model_id, threat_id, **kwargs)  # noqa: E501
            return data

    def update_threat_model_threat_with_http_info(self, body, threat_model_id, threat_id, **kwargs):  # noqa: E501
        """Update a threat  # noqa: E501

        Updates a specific threat within the threat model  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_threat_model_threat_with_http_info(body, threat_model_id, threat_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ThreatInput body: (required)
        :param str threat_model_id: Unique identifier of the threat model (UUID) (required)
        :param str threat_id: Unique identifier of the threat (UUID) (required)
        :return: Threat
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'threat_model_id', 'threat_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_threat_model_threat" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_threat_model_threat`")  # noqa: E501
        # verify the required parameter 'threat_model_id' is set
        if ('threat_model_id' not in params or
                params['threat_model_id'] is None):
            raise ValueError("Missing the required parameter `threat_model_id` when calling `update_threat_model_threat`")  # noqa: E501
        # verify the required parameter 'threat_id' is set
        if ('threat_id' not in params or
                params['threat_id'] is None):
            raise ValueError("Missing the required parameter `threat_id` when calling `update_threat_model_threat`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'threat_model_id' in params:
            path_params['threat_model_id'] = params['threat_model_id']  # noqa: E501
        if 'threat_id' in params:
            path_params['threat_id'] = params['threat_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/threat_models/{threat_model_id}/threats/{threat_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Threat',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
