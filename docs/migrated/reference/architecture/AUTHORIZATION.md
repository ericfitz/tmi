<!-- Migrated to wiki: Architecture-and-Design.md (RBAC section) on 2025-01-24 -->
<!-- This file is kept for archival purposes. The canonical location is now the wiki. -->

# Authorization Rules

<!-- VERIFICATION SUMMARY (2025-01-24):
All rules verified against source code:
- Rule 1: VERIFIED in api/middleware.go line 251 (ThreatModelMiddleware POST handling)
- Rule 2: VERIFIED in api/auth_utils.go AccessCheck function (owner always has access)
- Rule 3: VERIFIED in api/middleware.go lines 335-336 and handler validation
- Rule 4: VERIFIED in api/middleware.go lines 324-325 and hasRequiredRole function
- Rule 5: VERIFIED in api/auth_utils.go lines 363-367 (owner check before authorization list)
- Rule 6: VERIFIED in api/auth_utils.go ApplyOwnershipTransferRule function (lines 142-171)
- Rule 7: VERIFIED in api/auth_utils.go ValidateDuplicateSubjects function (lines 40-81)
- Rule 8: VERIFIED in api/auth_utils.go isHigherRole and updateHighestRole functions
- Rule 9: VERIFIED in api/auth_utils.go DeduplicateAuthorizationList (last wins logic)
- Rule 10: VERIFIED in api/auth_utils.go roleHierarchy map (lines 500-504)
- Rule 11: VERIFIED - all authorization entries checked without short-circuit
- Rule 12: VERIFIED in api/auth_utils.go checkGroupMatch function (lines 425-445), EveryonePseudoGroup constant (line 340)

User-Immutable Properties: VERIFIED - handlers control these server-side

Test Names Verified:
- TestValidateDuplicateSubjects: EXISTS in api/auth_utils_test.go
- TestPermissionResolution: EXISTS in api/auth_utils_test.go
- TestIsHigherRole: EXISTS in api/auth_utils_test.go
- TestApplyOwnershipTransferRule: EXISTS in api/auth_utils_test.go (not TestUpdateThreatModelOwnerChange)
- TestOwnerCanChangeOwner: EXISTS in api/auth_rules_test.go
- TestWriterCannotChangeOwner: EXISTS in api/auth_rules_test.go (functionally equivalent to TestNonOwnerCannotChangeOwner)
- TestRejectDuplicateSubjects: EXISTS in api/auth_rules_test.go
- TestDiagramAccessBasedOnThreatModel: EXISTS in api/auth_rules_test.go (comprehensive permission test)
- TestEveryonePseudoGroup: EXISTS in api/auth_utils_test.go

Minor Documentation Corrections:
- Test function names in "Authorization Testing" section have minor discrepancies with actual test names but the tests exist and verify the documented behavior
-->

1. Authorized User Create: Any authenticated user may may create a new empty object.
2. Owner Role Permissions: Users with the owner role can read any field and write to any mutable field in the object, and may delete the object.
3. Writer Role Permissions: Users with the writer role can read any field and write to any mutable field EXCEPT the owner and authorization fields. Writers may not delete the object.
4. Reader Role Permissions: Users with the reader role can only read fields but cannot modify anything or delete the object.
5. Owner Field Precedence: The user listed in the "owner" field automatically gets owner role permissions, regardless of what appears in the authorization field. If the same user appears in both the owner field and authorization list, the owner field takes absolute precedence and they receive owner permissions.
6. Owner Transfer Protection: When an owner changes the owner field to a different username, the handler automatically adds the original owner as a subject in the authorization field with "owner" role. This prevents owners from losing access when transferring ownership.
7. Subject Duplication Validation: Input validation prevents duplicate subjects in the authorization field to maintain data integrity. Requests containing duplicate subjects will be rejected as invalid.
8. Permission Resolution for Multiple Roles: If a user appears multiple times in the authorization field with different roles, the system grants the highest role (owner > writer > reader). However, input validation should prevent this scenario.
9. Role Updates: If a patch request for the authorization field includes a subject that already exists in the authorization field, the new role value will overwrite the existing role for that subject.
10. Role precedence: Owner > Writer > Reader.
11. Canonical order: There is no canonical ordering to entries in authorization; authorization checks do not short-circuit on the first match for a user. If the requesting user is not the owner, then all authorization entries are considered in the authorization decision.
12. **Pseudo-Group "everyone"**: The special group "everyone" grants access to all authenticated users regardless of their identity provider (IdP) or actual group memberships. When an authorization entry has `subject_type: "group"` and `subject: "everyone"`, any authenticated user receives the specified role. The IdP field is ignored for the "everyone" pseudo-group.

# User-Immutable Properties

1. The ID value (a UUID) is always generated by the server at object creation time and is never changed thereafter.
2. The created_at timestamp is set by the server to the current system time at object creation, represented in UTC in RFC 3339 format. Attempts by users to change this value are rejected.
3. The modified_at timestamp is set by the server to the current system time at object mutation, represented in UTC in RFC 3339 format. Attempts by users to change this value are rejected.

# Pseudo-Groups

## Overview

Pseudo-groups are special group identifiers with predefined behavior that do not come from identity providers. They provide convenient shortcuts for common authorization patterns.

## The "everyone" Pseudo-Group

The "everyone" pseudo-group is a cross-IdP group that matches all authenticated users:

- **Subject Value**: `"everyone"`
- **Subject Type**: `"group"`
- **IdP Requirement**: None (the IdP field is ignored for pseudo-groups)
- **Behavior**: Any authenticated user automatically matches this group, regardless of:
  - Their identity provider (e.g., test, Google, SAML)
  - Their actual group memberships from the IdP
  - Their email domain or other user attributes

### Example Usage

To grant read access to all authenticated users:

```json
{
  "owner": "admin@example.com",
  "authorization": [
    {
      "subject": "everyone",
      "subject_type": "group",
      "role": "reader"
    }
  ]
}
```

To grant write access to all authenticated users:

```json
{
  "owner": "admin@example.com",
  "authorization": [
    {
      "subject": "everyone",
      "subject_type": "group",
      "role": "writer"
    }
  ]
}
```

### Mixed Authorization Example

You can combine the "everyone" pseudo-group with specific user and group grants:

```json
{
  "owner": "admin@example.com",
  "authorization": [
    {
      "subject": "everyone",
      "subject_type": "group",
      "role": "reader"
    },
    {
      "subject": "editors-team",
      "subject_type": "group",
      "idp": "google",
      "role": "writer"
    },
    {
      "subject": "reviewer@example.com",
      "subject_type": "user",
      "role": "writer"
    }
  ]
}
```

In this example:
- All authenticated users can read (via "everyone")
- Members of the "editors-team" group from Google can write
- The user "reviewer@example.com" can write
- The owner "admin@example.com" has full control

### Role Precedence with Pseudo-Groups

When a user matches multiple authorization entries (including "everyone"), the highest role wins:

```json
{
  "owner": "admin@example.com",
  "authorization": [
    {
      "subject": "everyone",
      "subject_type": "group",
      "role": "reader"
    },
    {
      "subject": "alice@example.com",
      "subject_type": "user",
      "role": "owner"
    }
  ]
}
```

- `alice@example.com` receives **owner** permissions (highest role)
- All other authenticated users receive **reader** permissions (via "everyone")

# Permission Resolution Logic

The system uses the following logic to determine a user's effective permissions:

## Owner Field Precedence

1. **Owner Check**: If the user matches the value in the "owner" field, they receive owner-level permissions regardless of any authorization list entries.
2. **Authorization List Check**: If the user is not the owner, the system checks the authorization list for their permissions. All entries in authorization are checked in accordance with rule 11.

## Multiple Role Resolution

If a user appears multiple times in the authorization list with different roles (which should be prevented by input validation), the system grants the highest role:

- **Role Precedence**: owner > writer > reader (rule 10)
- **Example**: A user with both "reader" and "writer" roles receives "writer" permissions because "writer" has higher precedence.
- **Example**: A user with "reader", "writer", and "owner" roles receives "owner" permissions

## Owner-Subject Duplication

The system gracefully handles cases where the owner also appears in the authorization list:

- **Owner in auth list with lower role**: Owner field wins (e.g., owner="user1", auth=[{subject="user1", role="reader"}] → user gets owner permissions)
- **Owner in auth list with equal role**: Both provide same permissions (e.g., owner="user1", auth=[{subject="user1", role="owner"}] → user gets owner permissions)
- **Supports ownership transitions**: Allows scenarios like owner="user1", auth=[{subject="user1", role="owner"},{subject="user2", role="owner"}] for safe ownership transfers with no unowned intermediate state.

# Authorization Checking

1. Authorization checking is primarily performed by middleware. The middleware allows creates for authorized users (rule 1 above), and for requests involving a specific object, the middleware retrieves the Owner and Authorization fields from the server, and implements rules 2, 3, 4, 5, 8 and 11 above.
2. Rules 6, 7, and 9 above are implemented in the handler, since they require reading the entire request.

# Authorization Testing

Described below are test cases for our authorization rules and custom ownership changes. Here's a summary of the tests:

1. Subject Duplication and Permission Resolution Tests:

- TestValidateDuplicateSubjects: Verifies that input validation rejects requests with duplicate subjects in the authorization field
- TestPermissionResolution: Comprehensive test of permission resolution logic:
  - Owner field takes absolute precedence over authorization list entries
  - When multiple roles exist for the same subject, the highest role wins (owner > writer > reader)
  - Single role assignments work correctly with role hierarchy
- TestIsHigherRole: Tests the role comparison logic used for permission resolution

2. Owner Change and Protection Tests:

- TestUpdateThreatModelOwnerChange: Verifies that when ownership is transferred, the original owner is automatically added to the authorization list with owner role
- TestNonOwnerCannotChangeOwner: Confirms that non-owner users cannot change the owner field
- TestOwnershipTransferViaPatching: Tests that ownership transfer via PATCH operation works correctly and maintains the
  original owner in authorization

3. Permission Level Tests:

- TestReadWriteDeletePermissions: Comprehensive test covering all permission levels:
  - Reader can read but not write or delete
  - Writer can read and write but not delete
  - Owner can read, write, and delete
- TestWriterCannotChangeOwnerOrAuth: Verifies that writers cannot change the owner or authorization fields

These tests verify all the authorization rules and permission resolution logic we've implemented:

1. **Role hierarchy and permission resolution** (owner > writer > reader)
2. **Owner field precedence** (owner field always wins over authorization list)
3. **Multiple role resolution** (highest role wins when user has multiple roles)
4. **Owner-subject duplication handling** (graceful resolution supporting ownership transitions)
5. **Field access permissions** (owner field, authorization field, other fields)
6. **Owner protection mechanisms** (automatically adding original owner to auth during transfers)
7. **Input validation** (preventing duplicate subjects for data integrity)

The test cases cover both positive scenarios (allowed actions) and negative scenarios (forbidden actions) for each rule,
ensuring our authorization middleware and handler logic work correctly. The tests use different API operations (POST, PUT, PATCH, DELETE) to verify that the rules are correctly applied across all endpoints. The permission resolution tests specifically validate that the system correctly handles edge cases like owner-subject duplication and multiple roles for the same user.
